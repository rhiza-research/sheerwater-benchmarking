{
  "annotations": {
    "list": [
      {
        "builtIn": 1,
        "datasource": {
          "type": "grafana",
          "uid": "-- Grafana --"
        },
        "enable": true,
        "hide": true,
        "iconColor": "rgba(0, 211, 255, 1)",
        "name": "Annotations & Alerts",
        "type": "dashboard"
      }
    ]
  },
  "editable": true,
  "fiscalYearStartMonth": 0,
  "graphTooltip": 0,
  "id": 19,
  "links": [],
  "panels": [
    {
      "datasource": {
        "default": true,
        "type": "grafana-postgresql-datasource",
        "uid": "bdz3m3xs99p1cf"
      },
      "fieldConfig": {
        "defaults": {},
        "overrides": [
          {
            "matcher": {
              "id": "byName",
              "options": "forecast"
            },
            "properties": []
          },
          {
            "matcher": {
              "id": "byName",
              "options": "forecast"
            },
            "properties": []
          }
        ]
      },
      "gridPos": {
        "h": 9,
        "w": 18,
        "x": 0,
        "y": 0
      },
      "id": 3,
      "options": {
        "allData": {},
        "config": {},
        "data": [],
        "imgFormat": "png",
        "layout": {
          "barmode": "group",
          "font": {
            "family": "Inter, Helvetica, Arial, sans-serif"
          },
          "hoverlabel": {
            "bgcolor": "rgba(255, 255, 255, 0.95)"
          },
          "hovermode": "x unified",
          "margin": {
            "b": 30,
            "l": 40,
            "r": 10,
            "t": 5
          },
          "modebar": {
            "activecolor": "grey",
            "bgcolor": "rgba(255, 255, 255, 0)",
            "color": "lightgray",
            "orientation": "v",
            "remove": [
              "zoom2d",
              "pan2d",
              "select2d",
              "lasso2d",
              "zoomIn2d",
              "zoomOut2d"
            ]
          },
          "paper_bgcolor": "white",
          "plot_bgcolor": "white",
          "title": {
            "automargin": true
          },
          "xaxis": {
            "automargin": true,
            "autorange": true,
            "tickfont": {
              "size": 14
            },
            "ticklen": 4,
            "tickwidth": 1,
            "type": "date"
          },
          "yaxis": {
            "automargin": true,
            "autorange": false,
            "gridcolor": "rgba(0, 0, 0, 0.15)",
            "range": [
              -10,
              200
            ],
            "rangemode": "tozero",
            "tickfont": {
              "size": 14
            },
            "title": {
              "font": {
                "size": 16
              },
              "standoff": 20,
              "text": "Precipitation (mm)"
            },
            "type": "linear"
          }
        },
        "onclick": "// Event handling\n/*\n// 'data', 'variables', 'options', 'utils', and 'event' are passed as arguments\n\ntry {\n  const { type: eventType, data: eventData } = event;\n  const { timeZone, dayjs, locationService, getTemplateSrv } = utils;\n\n  switch (eventType) {\n    case 'click':\n      console.log('Click event:', eventData.points);\n      break;\n    case 'select':\n      console.log('Selection event:', eventData.range);\n      break;\n    case 'zoom':\n      console.log('Zoom event:', eventData);\n      break;\n    default:\n      console.log('Unhandled event type:', eventType, eventData);\n  }\n\n  console.log('Current time zone:', timeZone);\n  console.log('From time:', dayjs(variables.__from).format());\n  console.log('To time:', dayjs(variables.__to).format());\n\n  // Example of using locationService\n  // locationService.partial({ 'var-example': 'test' }, true);\n\n} catch (error) {\n  console.error('Error in onclick handler:', error);\n}\n*/\n  ",
        "resScale": 2,
        "script": "// Helper function to check if field has values\nfunction hasValues(field) {\n    return field && field.values && field.values.length > 0;\n}\n\n// Helper function to get field values\nfunction getValues(field) {\n    return field.values || field.values.buffer;\n}\n\nlet traces = [];\nconst series1 = data.series[0];\nconst timeValues = getValues(series1.fields[0]);  // time column\nconst forecastValues = getValues(series1.fields[1]);  // forecast column\n\n// Get unique forecast values\nconst uniqueForecasts = [...new Set(forecastValues)];\n\n// Colors for different forecast values\nconst colors = ['#4A90E2', '#50C878', '#9B6B9E', '#E37D54'];\n\n// Create a trace for each unique forecast value\nuniqueForecasts.forEach((forecastValue, index) => {\n    // Get indices where forecast equals this value\n    const indices = forecastValues.map((v, i) => v === forecastValue ? i : -1).filter(i => i !== -1);\n\n    // Get corresponding time and forecast values\n    const filteredTimes = indices.map(i => timeValues[i]);\n    const filteredForecasts = indices.map(i => forecastValues[i]);\n\n    traces.push({\n        x: filteredTimes,\n        y: filteredForecasts,\n        type: 'scatter',\n        mode: 'markers',\n        name: `${forecastValue}`,\n        marker: {\n            color: colors[index % colors.length],\n            size: 6,\n            symbol: 'circle'\n        }\n    });\n});\n\nreturn {\n    data: traces,\n    layout: {\n        xaxis: {\n            type: 'date',\n            title: 'Time'\n        },\n        yaxis: {\n            title: 'Forecast'\n        },\n        showlegend: true\n    }\n};",
        "syncTimeRange": false,
        "timeCol": ""
      },
      "pluginVersion": "1.8.1",
      "targets": [
        {
          "datasource": {
            "type": "grafana-postgresql-datasource",
            "uid": "bdz3m3xs99p1cf"
          },
          "editorMode": "code",
          "format": "table",
          "rawQuery": true,
          "rawSql": "select time::int as month, forecast, ${lead} \nfrom \"$tmp2m_tab_name\"\nORDER BY \"time\"",
          "refId": "A",
          "sql": {
            "columns": [
              {
                "parameters": [],
                "type": "function"
              }
            ],
            "groupBy": [
              {
                "property": {
                  "type": "string"
                },
                "type": "groupBy"
              }
            ],
            "limit": 50
          }
        }
      ],
      "title": "Precip (",
      "transparent": true,
      "type": "nline-plotlyjs-panel"
    },
    {
      "datasource": {
        "default": true,
        "type": "grafana-postgresql-datasource",
        "uid": "bdz3m3xs99p1cf"
      },
      "fieldConfig": {
        "defaults": {},
        "overrides": [
          {
            "matcher": {
              "id": "byName",
              "options": "forecast"
            },
            "properties": []
          },
          {
            "matcher": {
              "id": "byName",
              "options": "forecast"
            },
            "properties": []
          }
        ]
      },
      "gridPos": {
        "h": 10,
        "w": 12,
        "x": 0,
        "y": 9
      },
      "id": 1,
      "options": {
        "allData": {},
        "config": {},
        "data": [],
        "imgFormat": "png",
        "layout": {
          "font": {
            "family": "Inter, sans-serif"
          },
          "margin": {
            "b": 4,
            "l": 0,
            "r": 0,
            "t": 0
          },
          "paper_bgcolor": "#F4F5F5",
          "plog_bgcolor": "#F4F5F5",
          "title": {
            "automargin": true
          },
          "xaxis": {
            "automargin": true,
            "autorange": true,
            "type": "date"
          },
          "yaxis": {
            "automargin": true,
            "autorange": true
          }
        },
        "onclick": "",
        "resScale": 2,
        "script": "// Utility function to convert hex color to an RGB object\nfunction hexToRgb(hex) {\n    const bigint = parseInt(hex.slice(1), 16);\n    return {\n        r: (bigint >> 16) & 255,\n        g: (bigint >> 8) & 255,\n        b: bigint & 255\n    };\n}\n\n// Function to get interpolated color by passing a value from 0 to 1\nfunction getColor(value, cmin, cmax, colorMap) {\n    let colors;\n\n    // Define color scales based on the selected colormap\n    if (colorMap === 'BrBG') {\n        colors = [\n            \"#543005\",           \n            \"#8C510A\", \"#BF812D\", \"#DFC27D\", \"#F6E8C3\",\n            \"#F5F5F5\", \"#C7EAE5\", \"#80CDC1\", \"#35978F\", \"#01665E\",\n            \"#003C30\"            \n        ];        \n    } else if (colorMap === 'balance') {\n        colors = [\n            \"#2a0a0a\",          \n            \"#751b1b\", \"#b73c3c\", \"#e88484\", \"#f3c3c3\", // Negative side\n            \"#ffffff\",                                            // Neutral middle\n            \"#c3e4f3\", \"#84c2e8\", \"#3c9fb7\", \"#1b5e75\",  // Positive side\n            \"#0a2a2a\"            \n        ];      \n        colors = colors.reverse()  \n    } else if (colorMap === 'RdBu') {\n        colors = ['#ff0000', '#ffffff', '#0000ff'];        \n    } else {\n        throw new Error(\"Invalid colorMap. Choose 'BrBG', 'balance', or 'RdBu'.\");\n    }\n\n    let x;\n    if (value > 0) {\n        x = value / 2.0* cmax  + 0.5; // Map positive values from 0.5 to 1.0\n    } else if (val < 0) {\n        x = (value - cmin) / (-2.0* cmin); // Map negative values from 0.0 to 0.5\n    }    \n\n    // Clamp value between 0 and 1\n    x = Math.min(1, Math.max(0, x));\n    if (isNaN(x)) {\n        return `rgba(255, 255, 255, 0.5)`;\n    }\n\n    // Compute exact position in color array\n    const scaledValue = x * (colors.length - 1);\n    const lowerIndex = Math.floor(scaledValue);\n    const upperIndex = Math.ceil(scaledValue);\n\n    // Edge case: if at the end of the array, return the last color\n    if (lowerIndex === upperIndex) {\n        const color = hexToRgb(colors[lowerIndex]);\n        return `rgba(${color.r}, ${color.g}, ${color.b}, 0.5)`;\n    }\n\n    // Interpolate between the two colors\n    const lowerColor = hexToRgb(colors[lowerIndex]);\n    const upperColor = hexToRgb(colors[upperIndex]);\n    const t = scaledValue - lowerIndex;\n\n    // Interpolate RGB channels\n    const r = Math.round(lowerColor.r + t * (upperColor.r - lowerColor.r));\n    const g = Math.round(lowerColor.g + t * (upperColor.g - lowerColor.g));\n    const b = Math.round(lowerColor.b + t * (upperColor.b - lowerColor.b));\n\n    // Return the interpolated color as an rgb(r, g, b) string\n    return `rgba(${r}, ${g}, ${b}, 0.5)`;\n}\n\nlet series = data.series[0]\nif (series.length == 0) {\n  return {\n    data:[]\n  }\n}\n\nif (variables.time_grouping.current.value != 'None') {\n  idx= 1\n} else {\n  idx = 0\n}\nforecasts = series.fields[1+idx].values\nvalues = []\nskills = []\nheader = [\"Forecast\"]\norig_header = [\"forecast\"]\nlet max = -Infinity;\nlet min = Infinity;\n\nskill_baseline_idx = null;\nfor(var i = 0; i < forecasts.length; i = i+1) {\n  if(variables.baseline.current.value == forecasts[i]) {\n    skill_baseline_idx = i\n  }\n}\n\nbaseline_values = []\nfor(var i = 2 + idx; i < series.fields.length; i = i+1) {\n  baseline_values.push(series.fields[i].values[skill_baseline_idx])\n}\n\nfor(var i = 2 + idx; i < series.fields.length; i = i+1) {\n  v = series.fields[i].values\n  skill_values = []\n  for (var j = 0; j < v.length; j++) {\n    let val = parseFloat(v[j]);\n    if (val > max) {\n      max = val;\n    }\n    if (val < min) {\n      min = val;\n    }    \n    skill_values.push((1 - (val/baseline_values[(i - 2 - idx)])))\n  }\n  values.push(v)\n  skills.push(skill_values)\n  header.push(\"Week \" + (i-1-idx))\n  orig_header.push(\"week\" + (i-1-idx))\n}\n\nconsole.log(skills)\n\n// round to two decimal places\nvalues = values.map((week) => week.map((x) => {if (x) {return x.toFixed(2)} else {return '-'}}))\nforecasts = forecasts.map((forecast) => forecast.replaceAll('_', ' ').split(' ').map((word) => word[0].toUpperCase() + word.substring(1)).join(' '))\nvalues.unshift(forecasts)\n\n// Define a dictionary for custom renaming\nconst renameDict = {\n    \"Ecmwf Ifs Er\": \"ECMWF IFS ER\",\n    \"Ecmwf Ifs Er Debiased\": \"ECMWF IFS ER Debiased\",\n};\n\n// Apply custom renaming to the first column of cellValues\nvalues[0] = values[0].map(value => renameDict[value] || value);\n\n// assign the forecast colors\nforecast_colors = []\nfor (var i = 0; i < forecasts.length; i++) {\n  forecast_colors.push('rgba(0,0,0,0)')\n}\n\nlet skill_colors = []\n// assign the skill colors\nlet colorMap, cmax, cmin;\nif (variables['metric'].current.value == 'bias') {\n  colorMap = 'balance';\n  cmax = max;\n  cmin = min;\n}\nelse{\n  colorMap = 'RdBu';\n  cmax = 1;       \n  cmin = -1;\n}\nfor (var i = 0; i < skills.length; i++) {\n  let week_colors = [];\n  for(var j = 0; j < skills[i].length; j++) {\n    if (variables['metric'].current.value == 'acc' || variables['metric'].current.value == 'bias' ){\n      val = parseFloat(values[i+1][j]);  \n    } else {\n      val = parseFloat(skills[i][j]);  \n    }\n    week_colors.push(getColor(val, cmin, cmax, colorMap))\n  }\n  skill_colors.push(week_colors)\n}\n\n// Turn the metrics into links\norig_forecasts = series.fields[1+idx].values\nmetric = variables.metric.current.value\ngrid = variables.grid.current.value\nregion = variables.region.current.value\ntime_grouping = variables.time_grouping.current.value\ntime_filter = variables.time_filter.current.value\nfor(var i = 1; i < values.length; i++) {\n  for(var j = 0; j < values[i].length; j++) {\n    url = `/d/ae39q2k3jv668d/plotly-maps?orgId=1&var-forecast=${orig_forecasts[j]}&var-metric=${metric}&var-lead=${orig_header[i]}&var-truth=era5&var-grid=${grid}&var-region=${region}&var-time_grouping=${time_grouping}&var-time_filter=${time_filter}`\n    values[i][j] = `<a href=\"${url}\">` + values[i][j] + '</a>'\n  }\n}\n\nreturn {\n  data: [{\n  type: 'table',\n  header: {\n    values: header,\n    align: ['left', 'right', 'right', 'right', 'right'],\n    line: {width: 0, color: '#DBDDDE'},\n    font: {family: \"Inter, sans-serif\", size: 14, weight: \"bold\"},\n       fill: {\n\t\t\t\t\tcolor: ['rgba(0,0,0,0)']\n\t\t\t\t\t}\n  },\n  cells: {\n    values: values,\n    align: ['left', 'right', 'right', 'right', 'right'],\n    line: {color: \"#DBDDDE\", width: 1},\n    font: {family: \"Inter, sans-serif\", size: 14, color: [\"black\"]},\n    fill: {\n\t\t\t\t\tcolor: [forecast_colors,...skill_colors]\n\t\t\t\t\t},\n    height: 35\n\n  },\n  columnwidth: [1.2, 0.5, 0.5, 0.5, 0.5, 0.5]\n}]\n}\n  ",
        "syncTimeRange": false,
        "timeCol": ""
      },
      "pluginVersion": "1.8.1",
      "targets": [
        {
          "datasource": {
            "type": "grafana-postgresql-datasource",
            "uid": "bdz3m3xs99p1cf"
          },
          "editorMode": "code",
          "format": "table",
          "rawQuery": true,
          "rawSql": "select * from \"$tmp2m_tab_name\"\n ${time_filter_query}",
          "refId": "A",
          "sql": {
            "columns": [
              {
                "parameters": [],
                "type": "function"
              }
            ],
            "groupBy": [
              {
                "property": {
                  "type": "string"
                },
                "type": "groupBy"
              }
            ],
            "limit": 50
          }
        },
        {
          "datasource": {
            "type": "grafana-postgresql-datasource",
            "uid": "bdz3m3xs99p1cf"
          },
          "editorMode": "code",
          "format": "table",
          "hide": false,
          "rawQuery": true,
          "rawSql": "select '${baseline}'",
          "refId": "B",
          "sql": {
            "columns": [
              {
                "parameters": [],
                "type": "function"
              }
            ],
            "groupBy": [
              {
                "property": {
                  "type": "string"
                },
                "type": "groupBy"
              }
            ],
            "limit": 50
          }
        }
      ],
      "title": "Weekly 2m Temperature Results (C)",
      "transparent": true,
      "type": "nline-plotlyjs-panel"
    },
    {
      "datasource": {
        "default": true,
        "type": "grafana-postgresql-datasource",
        "uid": "bdz3m3xs99p1cf"
      },
      "fieldConfig": {
        "defaults": {},
        "overrides": [
          {
            "matcher": {
              "id": "byName",
              "options": "forecast"
            },
            "properties": []
          },
          {
            "matcher": {
              "id": "byName",
              "options": "forecast"
            },
            "properties": []
          }
        ]
      },
      "gridPos": {
        "h": 10,
        "w": 12,
        "x": 12,
        "y": 9
      },
      "id": 2,
      "options": {
        "allData": {},
        "config": {},
        "data": [],
        "imgFormat": "png",
        "layout": {
          "font": {
            "family": "Inter, sans-serif"
          },
          "margin": {
            "b": 0,
            "l": 0,
            "r": 0,
            "t": 0
          },
          "paper_bgcolor": "#F4F5F5",
          "plog_bgcolor": "#F4F5F5",
          "title": {
            "automargin": true
          },
          "xaxis": {
            "automargin": true,
            "autorange": true,
            "type": "date"
          },
          "yaxis": {
            "automargin": true,
            "autorange": true
          }
        },
        "onclick": "",
        "resScale": 0,
        "script": "// Utility function to convert hex color to an RGB object\nfunction hexToRgb(hex) {\n    const bigint = parseInt(hex.slice(1), 16);\n    return {\n        r: (bigint >> 16) & 255,\n        g: (bigint >> 8) & 255,\n        b: bigint & 255\n    };\n}\n\n// Function to get interpolated color by passing a value from 0 to 1\nfunction getColor(value, cmin, cmax, colorMap) {\n    let colors;\n\n    // Define color scales based on the selected colormap\n    if (colorMap === 'BrBG') {\n        colors = [\n            \"#543005\",           \n            \"#8C510A\", \"#BF812D\", \"#DFC27D\", \"#F6E8C3\",\n            \"#F5F5F5\", \"#C7EAE5\", \"#80CDC1\", \"#35978F\", \"#01665E\",\n            \"#003C30\"            \n        ];        \n    } else if (colorMap === 'balance') {\n        colors = [\n            \"#2a0a0a\",          \n            \"#751b1b\", \"#b73c3c\", \"#e88484\", \"#f3c3c3\", // Negative side\n            \"#ffffff\",                                            // Neutral middle\n            \"#c3e4f3\", \"#84c2e8\", \"#3c9fb7\", \"#1b5e75\",  // Positive side\n            \"#0a2a2a\"            \n        ];      \n        colors = colors.reverse()  \n    } else if (colorMap === 'RdBu') {\n        colors = ['#ff0000', '#ffffff', '#0000ff'];        \n    } else {\n        throw new Error(\"Invalid colorMap. Choose 'BrBG', 'balance', or 'RdBu'.\");\n    }\n\n    let x;\n    if (value > 0) {\n        x = value / 2.0* cmax  + 0.5; // Map positive values from 0.5 to 1.0\n    } else if (val < 0) {\n        x = (value - cmin) / (-2.0* cmin); // Map negative values from 0.0 to 0.5\n    }    \n\n    // Clamp value between 0 and 1\n    x = Math.min(1, Math.max(0, x));\n    if (isNaN(x)) {\n        return `rgba(255, 255, 255, 0.5)`;\n    }\n\n    // Compute exact position in color array\n    const scaledValue = x * (colors.length - 1);\n    const lowerIndex = Math.floor(scaledValue);\n    const upperIndex = Math.ceil(scaledValue);\n\n    // Edge case: if at the end of the array, return the last color\n    if (lowerIndex === upperIndex) {\n        const color = hexToRgb(colors[lowerIndex]);\n        return `rgba(${color.r}, ${color.g}, ${color.b}, 0.5)`;\n    }\n\n    // Interpolate between the two colors\n    const lowerColor = hexToRgb(colors[lowerIndex]);\n    const upperColor = hexToRgb(colors[upperIndex]);\n    const t = scaledValue - lowerIndex;\n\n    // Interpolate RGB channels\n    const r = Math.round(lowerColor.r + t * (upperColor.r - lowerColor.r));\n    const g = Math.round(lowerColor.g + t * (upperColor.g - lowerColor.g));\n    const b = Math.round(lowerColor.b + t * (upperColor.b - lowerColor.b));\n\n    // Return the interpolated color as an rgb(r, g, b) string\n    return `rgba(${r}, ${g}, ${b}, 0.5)`;\n}\n\nlet series = data.series[0]\nif (series.length == 0) {\n  return {\n    data:[]\n  }\n}\n\nif (variables.time_grouping.current.value != 'None') {\n  idx= 1\n} else {\n  idx = 0\n}\nforecasts = series.fields[1+idx].values\nvalues = []\nskills = []\nheader = [\"Forecast\"]\norig_header = [\"forecast\"]\nlet max = -Infinity;\nlet min = Infinity;\n\nskill_baseline_idx = null;\nfor(var i = 0; i < forecasts.length; i = i+1) {\n  if(variables.baseline.current.value == forecasts[i]) {\n    skill_baseline_idx = i\n  }\n}\n\nbaseline_values = []\nfor(var i = 2 + idx; i < series.fields.length; i = i+1) {\n  baseline_values.push(series.fields[i].values[skill_baseline_idx])\n}\n\nfor(var i = 2 + idx; i < series.fields.length; i = i+1) {\n  v = series.fields[i].values\n  skill_values = []\n  for (var j = 0; j < v.length; j++) {\n    let val = parseFloat(v[j]);\n    if (val > max) {\n      max = val;\n    }\n    if (val < min) {\n      min = val;\n    }    \n    skill_values.push((1 - (val/baseline_values[(i - 2 - idx)])))\n  }\n  values.push(v)\n  skills.push(skill_values)\n  header.push(\"Week \" + (i-1-idx))\n  orig_header.push(\"week\" + (i-1-idx))\n}\n\nconsole.log(skills)\n\n// round to two decimal places\nvalues = values.map((week) => week.map((x) => {if (x) {return x.toFixed(2)} else {return '-'}}))\nforecasts = forecasts.map((forecast) => forecast.replaceAll('_', ' ').split(' ').map((word) => word[0].toUpperCase() + word.substring(1)).join(' '))\nvalues.unshift(forecasts)\n\n// Define a dictionary for custom renaming\nconst renameDict = {\n    \"Ecmwf Ifs Er\": \"ECMWF IFS ER\",\n    \"Ecmwf Ifs Er Debiased\": \"ECMWF IFS ER Debiased\",\n};\n\n// Apply custom renaming to the first column of cellValues\nvalues[0] = values[0].map(value => renameDict[value] || value);\n\n// assign the forecast colors\nforecast_colors = []\nfor (var i = 0; i < forecasts.length; i++) {\n  forecast_colors.push('rgba(0,0,0,0)')\n}\n\nlet skill_colors = []\n// assign the skill colors\nlet colorMap, cmax, cmin;\nif (variables['metric'].current.value == 'bias') {\n  colorMap = 'BrBG';\n  cmax = max;\n  cmin = min;\n}\nelse{\n  colorMap = 'RdBu';\n  cmax = 1;       \n  cmin = -1;\n}\nfor (var i = 0; i < skills.length; i++) {\n  let week_colors = [];\n  for(var j = 0; j < skills[i].length; j++) {\n    if (variables['metric'].current.value == 'acc' || variables['metric'].current.value == 'bias' ){\n      val = parseFloat(values[i+1][j]);  \n    } else {\n      val = parseFloat(skills[i][j]);  \n    }\n    week_colors.push(getColor(val, cmin, cmax, colorMap))\n  }\n  skill_colors.push(week_colors)\n}\n\n// Turn the metrics into links\norig_forecasts = series.fields[1+idx].values\nmetric = variables.metric.current.value\ngrid = variables.grid.current.value\nregion = variables.region.current.value\ntime_grouping = variables.time_grouping.current.value\ntime_filter = variables.time_filter.current.value\nfor(var i = 1; i < values.length; i++) {\n  for(var j = 0; j < values[i].length; j++) {\n    url = `/d/ae39q2k3jv668d/plotly-maps?orgId=1&var-forecast=${orig_forecasts[j]}&var-metric=${metric}&var-lead=${orig_header[i]}&var-truth=era5&var-grid=${grid}&var-region=${region}&var-time_grouping=${time_grouping}&var-time_filter=${time_filter}`\n    values[i][j] = `<a href=\"${url}\">` + values[i][j] + '</a>'\n  }\n}\n\nreturn {\n  data: [{\n  type: 'table',\n  header: {\n    values: header,\n    align: ['left', 'right', 'right', 'right', 'right'],\n    line: {width: 0, color: '#DBDDDE'},\n    font: {family: \"Inter, sans-serif\", size: 14, weight: \"bold\"},\n       fill: {\n\t\t\t\t\tcolor: ['rgba(0,0,0,0)']\n\t\t\t\t\t}\n  },\n  cells: {\n    values: values,\n    align: ['left', 'right', 'right', 'right', 'right'],\n    line: {color: \"#DBDDDE\", width: 1},\n    font: {family: \"Inter, sans-serif\", size: 14, color: [\"black\"]},\n    fill: {\n\t\t\t\t\tcolor: [forecast_colors,...skill_colors]\n\t\t\t\t\t},\n    height: 35\n\n  },\n  columnwidth: [1.2, 0.5, 0.5, 0.5, 0.5, 0.5]\n}]\n}\n  ",
        "syncTimeRange": false,
        "timeCol": ""
      },
      "pluginVersion": "1.8.1",
      "targets": [
        {
          "datasource": {
            "type": "grafana-postgresql-datasource",
            "uid": "bdz3m3xs99p1cf"
          },
          "editorMode": "code",
          "format": "table",
          "rawQuery": true,
          "rawSql": "select * from \"$precip_tab_name\"\n ${time_filter_query}",
          "refId": "A",
          "sql": {
            "columns": [
              {
                "parameters": [],
                "type": "function"
              }
            ],
            "groupBy": [
              {
                "property": {
                  "type": "string"
                },
                "type": "groupBy"
              }
            ],
            "limit": 50
          }
        },
        {
          "datasource": {
            "type": "grafana-postgresql-datasource",
            "uid": "bdz3m3xs99p1cf"
          },
          "editorMode": "code",
          "format": "table",
          "hide": false,
          "rawQuery": true,
          "rawSql": "select '${baseline}'",
          "refId": "B",
          "sql": {
            "columns": [
              {
                "parameters": [],
                "type": "function"
              }
            ],
            "groupBy": [
              {
                "property": {
                  "type": "string"
                },
                "type": "groupBy"
              }
            ],
            "limit": 50
          }
        }
      ],
      "title": "Weekly Precipitation Results (mm)",
      "transparent": true,
      "type": "nline-plotlyjs-panel"
    }
  ],
  "schemaVersion": 39,
  "tags": [],
  "templating": {
    "list": [
      {
        "current": {
          "selected": false,
          "text": "MAE",
          "value": "mae"
        },
        "hide": 0,
        "includeAll": false,
        "label": "Metric",
        "multi": false,
        "name": "metric",
        "options": [
          {
            "selected": true,
            "text": "MAE",
            "value": "mae"
          },
          {
            "selected": false,
            "text": "CRPS",
            "value": "crps"
          },
          {
            "selected": false,
            "text": "RMSE",
            "value": "rmse"
          },
          {
            "selected": false,
            "text": "ACC",
            "value": "acc"
          },
          {
            "selected": false,
            "text": "Bias",
            "value": "bias"
          }
        ],
        "query": "MAE : mae, CRPS : crps, RMSE : rmse, ACC : acc, Bias : bias",
        "queryValue": "",
        "skipUrlSync": false,
        "type": "custom"
      },
      {
        "current": {
          "selected": false,
          "text": "Clim 1985-2014",
          "value": "climatology_2015"
        },
        "datasource": {
          "type": "grafana-postgresql-datasource",
          "uid": "bdz3m3xs99p1cf"
        },
        "definition": "select \nforecast as __value,\ncase\n when forecast = 'salient' then 'Salient' \nwhen forecast = 'climatology_2015' then 'Clim 1985-2014' \nwhen forecast = 'climatology_trend_2015' then 'Clim + Trend' \nwhen forecast = 'climatology_rolling' then 'Clim Rolling' \nwhen forecast = 'ecmwf_ifs_er' then 'ECMWF IFS ER' \nwhen forecast = 'ecmwf_ifs_er_debiased' then 'ECMWF IFS ER Debiased' \n else forecast\nend as __text\nfrom \"${precip_tab_name_baseline}\" where week1 is not null and forecast != 'salient'",
        "hide": 0,
        "includeAll": false,
        "label": "Baseline",
        "multi": false,
        "name": "baseline",
        "options": [],
        "query": "select \nforecast as __value,\ncase\n when forecast = 'salient' then 'Salient' \nwhen forecast = 'climatology_2015' then 'Clim 1985-2014' \nwhen forecast = 'climatology_trend_2015' then 'Clim + Trend' \nwhen forecast = 'climatology_rolling' then 'Clim Rolling' \nwhen forecast = 'ecmwf_ifs_er' then 'ECMWF IFS ER' \nwhen forecast = 'ecmwf_ifs_er_debiased' then 'ECMWF IFS ER Debiased' \n else forecast\nend as __text\nfrom \"${precip_tab_name_baseline}\" where week1 is not null and forecast != 'salient'",
        "refresh": 1,
        "regex": "",
        "skipUrlSync": false,
        "sort": 0,
        "type": "query"
      },
      {
        "current": {
          "selected": false,
          "text": "ERA5",
          "value": "era5"
        },
        "hide": 0,
        "includeAll": false,
        "label": "Ground Truth",
        "multi": false,
        "name": "truth",
        "options": [
          {
            "selected": true,
            "text": "ERA5",
            "value": "era5"
          }
        ],
        "query": "ERA5 : era5",
        "queryValue": "",
        "skipUrlSync": false,
        "type": "custom"
      },
      {
        "current": {
          "selected": false,
          "text": "1.5",
          "value": "global1_5"
        },
        "hide": 0,
        "includeAll": false,
        "label": "Grid",
        "multi": false,
        "name": "grid",
        "options": [
          {
            "selected": true,
            "text": "1.5",
            "value": "global1_5"
          },
          {
            "selected": false,
            "text": "0.25",
            "value": "global0_25"
          }
        ],
        "query": "1.5 : global1_5, 0.25 : global0_25",
        "queryValue": "",
        "skipUrlSync": false,
        "type": "custom"
      },
      {
        "current": {
          "selected": false,
          "text": "Africa",
          "value": "africa"
        },
        "hide": 0,
        "includeAll": false,
        "label": "Region",
        "multi": false,
        "name": "region",
        "options": [
          {
            "selected": true,
            "text": "Africa",
            "value": "africa"
          },
          {
            "selected": false,
            "text": "East Africa",
            "value": "east_africa"
          },
          {
            "selected": false,
            "text": "Global",
            "value": "global"
          },
          {
            "selected": false,
            "text": "CONUS",
            "value": "conus"
          }
        ],
        "query": "Africa : africa, East Africa : east_africa, Global : global, CONUS : conus",
        "queryValue": "",
        "skipUrlSync": false,
        "type": "custom"
      },
      {
        "current": {
          "selected": false,
          "text": "None",
          "value": "None"
        },
        "hide": 0,
        "includeAll": false,
        "label": "Time Grouping",
        "multi": false,
        "name": "time_grouping",
        "options": [
          {
            "selected": true,
            "text": "None",
            "value": "None"
          },
          {
            "selected": false,
            "text": "Month of Year",
            "value": "month_of_year"
          },
          {
            "selected": false,
            "text": "Year",
            "value": "year"
          }
        ],
        "query": "None : None, Month of Year : month_of_year, Year : year",
        "queryValue": "",
        "skipUrlSync": false,
        "type": "custom"
      },
      {
        "current": {
          "selected": false,
          "text": "d4fb802fa9be6d4d3eb0f4ee42774b17",
          "value": "d4fb802fa9be6d4d3eb0f4ee42774b17"
        },
        "datasource": {
          "type": "grafana-postgresql-datasource",
          "uid": "bdz3m3xs99p1cf"
        },
        "definition": "select * from md5('summary_metrics_table/2022-12-31_${grid}_lsm_${metric}_${region}_2016-01-01_${time_grouping}_${truth}_tmp2m')",
        "hide": 2,
        "includeAll": false,
        "multi": false,
        "name": "tmp2m_tab_name",
        "options": [],
        "query": "select * from md5('summary_metrics_table/2022-12-31_${grid}_lsm_${metric}_${region}_2016-01-01_${time_grouping}_${truth}_tmp2m')",
        "refresh": 2,
        "regex": "",
        "skipUrlSync": false,
        "sort": 0,
        "type": "query"
      },
      {
        "current": {
          "selected": false,
          "text": "7928d9fd350a9cd889fa8bbedf885539",
          "value": "7928d9fd350a9cd889fa8bbedf885539"
        },
        "datasource": {
          "type": "grafana-postgresql-datasource",
          "uid": "bdz3m3xs99p1cf"
        },
        "definition": "select * from md5('summary_metrics_table/2022-12-31_${grid}_lsm_${metric}_${region}_2016-01-01_${time_grouping}_${truth}_precip')",
        "hide": 2,
        "includeAll": false,
        "multi": false,
        "name": "precip_tab_name",
        "options": [],
        "query": "select * from md5('summary_metrics_table/2022-12-31_${grid}_lsm_${metric}_${region}_2016-01-01_${time_grouping}_${truth}_precip')",
        "refresh": 2,
        "regex": "",
        "skipUrlSync": false,
        "sort": 0,
        "type": "query"
      },
      {
        "current": {
          "selected": false,
          "text": "select v.* from (values ('None')) v(t)",
          "value": "select v.* from (values ('None')) v(t)"
        },
        "datasource": {
          "type": "grafana-postgresql-datasource",
          "uid": "bdz3m3xs99p1cf"
        },
        "definition": "select \nCASE\n    WHEN v.g = 'None' THEN 'select v.* from (values (''None'')) v(t)'\n    ELSE 'select distinct time from \"${precip_tab_name}\"'\nEND\nfrom (values ('$time_grouping')) v(g)",
        "hide": 2,
        "includeAll": false,
        "multi": false,
        "name": "time_filter_filter_query",
        "options": [],
        "query": "select \nCASE\n    WHEN v.g = 'None' THEN 'select v.* from (values (''None'')) v(t)'\n    ELSE 'select distinct time from \"${precip_tab_name}\"'\nEND\nfrom (values ('$time_grouping')) v(g)",
        "refresh": 1,
        "regex": "",
        "skipUrlSync": false,
        "sort": 0,
        "type": "query"
      },
      {
        "current": {
          "selected": false,
          "text": "None",
          "value": "None"
        },
        "datasource": {
          "type": "grafana-postgresql-datasource",
          "uid": "bdz3m3xs99p1cf"
        },
        "definition": "${time_filter_filter_query:raw}",
        "hide": 0,
        "includeAll": false,
        "label": "Time Filter",
        "multi": false,
        "name": "time_filter",
        "options": [],
        "query": "${time_filter_filter_query:raw}",
        "refresh": 1,
        "regex": "",
        "skipUrlSync": false,
        "sort": 3,
        "type": "query"
      },
      {
        "current": {
          "selected": false,
          "text": "",
          "value": ""
        },
        "datasource": {
          "type": "grafana-postgresql-datasource",
          "uid": "bdz3m3xs99p1cf"
        },
        "definition": "select \nCASE\n    WHEN v.g = 'None' THEN ''\n    ELSE 'where time = ' || v.t\nEND\nfrom (values ('$time_filter', '$time_grouping')) v(t, g)",
        "hide": 2,
        "includeAll": false,
        "multi": false,
        "name": "time_filter_query",
        "options": [],
        "query": "select \nCASE\n    WHEN v.g = 'None' THEN ''\n    ELSE 'where time = ' || v.t\nEND\nfrom (values ('$time_filter', '$time_grouping')) v(t, g)",
        "refresh": 1,
        "regex": "",
        "skipUrlSync": false,
        "sort": 0,
        "type": "query"
      },
      {
        "current": {
          "selected": false,
          "text": "af1d30598d21c5b08a75924bc1ed141b",
          "value": "af1d30598d21c5b08a75924bc1ed141b"
        },
        "datasource": {
          "type": "grafana-postgresql-datasource",
          "uid": "bdz3m3xs99p1cf"
        },
        "definition": "select * from md5('biweekly_summary_metrics_table/2022-12-31_${grid}_lsm_${metric}_${region}_2016-01-01_${time_grouping}_${truth}_tmp2m')",
        "hide": 2,
        "includeAll": false,
        "multi": false,
        "name": "tmp2m_tab_name_biweekly",
        "options": [],
        "query": "select * from md5('biweekly_summary_metrics_table/2022-12-31_${grid}_lsm_${metric}_${region}_2016-01-01_${time_grouping}_${truth}_tmp2m')",
        "refresh": 2,
        "regex": "",
        "skipUrlSync": false,
        "sort": 0,
        "type": "query"
      },
      {
        "current": {
          "selected": false,
          "text": "1109d506b2a17c1c279aa49bc22a3b4b",
          "value": "1109d506b2a17c1c279aa49bc22a3b4b"
        },
        "datasource": {
          "type": "grafana-postgresql-datasource",
          "uid": "bdz3m3xs99p1cf"
        },
        "definition": "select * from md5('biweekly_summary_metrics_table/2022-12-31_${grid}_lsm_${metric}_${region}_2016-01-01_${time_grouping}_${truth}_precip')",
        "hide": 2,
        "includeAll": false,
        "multi": false,
        "name": "precip_tab_name_biweekly",
        "options": [],
        "query": "select * from md5('biweekly_summary_metrics_table/2022-12-31_${grid}_lsm_${metric}_${region}_2016-01-01_${time_grouping}_${truth}_precip')",
        "refresh": 2,
        "regex": "",
        "skipUrlSync": false,
        "sort": 0,
        "type": "query"
      },
      {
        "current": {
          "selected": false,
          "text": "7928d9fd350a9cd889fa8bbedf885539",
          "value": "7928d9fd350a9cd889fa8bbedf885539"
        },
        "datasource": {
          "type": "grafana-postgresql-datasource",
          "uid": "bdz3m3xs99p1cf"
        },
        "definition": "select * from md5('summary_metrics_table/2022-12-31_${grid}_lsm_${metric}_${region}_2016-01-01_${time_grouping}_${truth}_precip')",
        "hide": 2,
        "includeAll": false,
        "multi": false,
        "name": "precip_tab_name_baseline",
        "options": [],
        "query": "select * from md5('summary_metrics_table/2022-12-31_${grid}_lsm_${metric}_${region}_2016-01-01_${time_grouping}_${truth}_precip')",
        "refresh": 2,
        "regex": "",
        "skipUrlSync": false,
        "sort": 0,
        "type": "query"
      },
      {
        "current": {
          "selected": false,
          "text": "Week 1",
          "value": "week1"
        },
        "hide": 0,
        "includeAll": false,
        "label": "Lead",
        "multi": false,
        "name": "lead",
        "options": [
          {
            "selected": true,
            "text": "Week 1",
            "value": "week1"
          },
          {
            "selected": false,
            "text": "Week 2",
            "value": "week2"
          },
          {
            "selected": false,
            "text": "Week 3",
            "value": "week3"
          },
          {
            "selected": false,
            "text": "Week 4",
            "value": "week4"
          },
          {
            "selected": false,
            "text": "Week 5",
            "value": "week5"
          },
          {
            "selected": false,
            "text": "Week 6",
            "value": "week6"
          }
        ],
        "query": "Week 1 : week1, Week 2 : week2, Week 3 : week3, Week 4 : week4, Week 5 : week5, Week 6 : week6",
        "queryValue": "",
        "skipUrlSync": false,
        "type": "custom"
      }
    ]
  },
  "time": {
    "from": "now-6h",
    "to": "now"
  },
  "timepicker": {},
  "timezone": "utc",
  "title": "Summary Results Tables w/Timeseries",
  "uid": "ceavawaipj7y8c",
  "version": 2,
  "weekStart": ""
}

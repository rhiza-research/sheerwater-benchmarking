{
  "annotations": {
    "list": [
      {
        "builtIn": 1,
        "datasource": {
          "type": "grafana",
          "uid": "-- Grafana --"
        },
        "enable": true,
        "hide": true,
        "iconColor": "rgba(0, 211, 255, 1)",
        "name": "Annotations & Alerts",
        "type": "dashboard"
      }
    ]
  },
  "editable": true,
  "fiscalYearStartMonth": 0,
  "graphTooltip": 0,
  "id": 17,
  "links": [],
  "panels": [
    {
      "datasource": {
        "uid": "bdz3m3xs99p1cf"
      },
      "fieldConfig": {
        "defaults": {
          "thresholds": {
            "mode": "absolute",
            "steps": [
              {
                "color": "green",
                "value": null
              },
              {
                "color": "red",
                "value": 80
              }
            ]
          }
        },
        "overrides": []
      },
      "gridPos": {
        "h": 8,
        "w": 24,
        "x": 0,
        "y": 0
      },
      "id": 13,
      "options": {
        "afterRender": "// window.onload = function () {\n//     renderMathInElement(document.body, {\n//         delimiters: [\n//             { left: \"$$\", right: \"$$\", display: true },\n//             { left: \"\\\\(\", right: \"\\\\)\", display: false }\n//         ]\n//     });\n// };\n",
        "content": "\n #### Selected Metric: {{#if (eq metric \"mae\")}}MAE {{/if}} {{#if (eq metric \"rmse\")}}RMSE{{/if}} {{#if (eq metric \"crps\")}}CRPS{{/if}} {{#if (eq metric \"bias\")}}Bias{{/if}} {{#if (eq metric \"smape\")}}SMAPE{{/if}} {{#if (eq metric \"seeps\")}}SEEPS{{/if}} {{#if (eq metric \"acc\")}}ACC{{/if}}  {{#if (eq metric \"heidke-1-5-10-20\")}}Heidke 1/5/10/20mm{{/if}} {{#if (eq metric \"far-1\")}}FAR 1mm{{/if}} {{#if (eq metric \"far-5\")}}FAR 5mm{{/if}} {{#if (eq metric \"far-10\")}}FAR 10mm{{/if}} {{#if (eq metric \"pod-1\")}}POD 1mm{{/if}} {{#if (eq metric \"pod-5\")}}POD 5mm{{/if}} {{#if (eq metric \"pod-10\")}}POD 10mm{{/if}} {{#if (eq metric \"ets-1\")}}ETS 1mm{{/if}} {{#if (eq metric \"ets-5\")}}ETS 5mm{{/if}} {{#if (eq metric \"ets-10\")}}ETS 10mm{{/if}}\n\n{{#if (eq metric \"mae\")}}\nMean absolute error (MAE) measures the average magnitude of the errors in a set of predictions, without considering\ntheir direction.\\\n<span style=\"color: red; font-weight: bold;\">ðŸ”´ Smaller is better â€” lower MAE means better predictions.</span> \n\n{{else if (eq metric \"crps\")}}\nContinuous ranked probability score (CRPS) assesses the accuracy of probabilistic forecasts by comparing the cumulative\ndistribution function of forecasts to the observed values.\\\n<span style=\"color: red; font-weight: bold;\">ðŸ”´ Smaller is better â€” lower CRPS indicates better probabilistic forecasting skill.</span>\n\n{{else if (eq metric \"rmse\")}}\nRoot mean squared error (RMSE) gives higher weight to large errors, making it more sensitive to outliers.\\\n<span style=\"color: red; font-weight: bold;\">ðŸ”´ Smaller is better â€” lower RMSE means better predictions.</span>\n\n{{else if (eq metric \"acc\")}}\nAnomaly correlation coefficient (ACC) ACC is a measure of how well the forecast anomalies have represented the observed anomalies\nrelative to climatology. We used 1991-2020 climatology (years inclusive) for our ACC calculation.\\\n<span style=\"color: green; font-weight: bold;\">ðŸŸ¢ Larger is better â€” higher ACC means better predictions. Range [-1, 1].</span>\n\n{{else if (eq metric \"bias\")}}\nBias measures the signed magnitude of errors in a set of predictions. \\\n<span style=\"color: gray; font-weight: bold;\">âšª Ideal value = 0.0 â€” Bias should be close to 0.0 for an unbiased forecast.</span>\n\n{{else if (eq metric \"smape\")}}\nSymmetric mean absolute percentage error (SMAPE) is a normalized version of Mean Absolute Percentage Error (MAPE) and calculate sthe error as a percentage of the total value. We only calculate SMAPE for precipitation.\\\n<span style=\"color: red; font-weight: bold;\">ðŸ”´ Smaller is better â€” lower SMAPE indicates better forecasting accuracy. Range [0, 1].</span>\n\n{{else if (eq metric \"seeps\")}}\nStable equitable error in probability space (SEEPS) is a score designed for evaluating rainfall forecasts while taking into account climactic difference in rainfall. Areas that are too dry or wet are exclued. \nWe include all cells with a 3-93% non-dry day frequency to ensure inclusion of relevant parts of Africa. We only calculate SEEPS for precipitation.\\\n<span style=\"color: red; font-weight: bold;\">ðŸ”´ Smaller is better â€” lower SEEPS indicates better forecasting accuracy. Good SEEPS for short term forecasts on cells that have 10-85% non-dry days are considered between 0-1.</span>\n\n{{else if (eq metric \"heidke-1-5-10-20\")}}\nHeidke skill score (HSS) compares the accuracy of a forecast to random chance for a set of predetermined rainfall thresholdsâ€”in this case, 1, 5, 10, and 20mm. We only calculate Heidke for precipitation.\\\n<span style=\"color: green; font-weight: bold;\">ðŸŸ¢ Larger is better â€” a higher HSS indicates better skill. Range [-&infin;, 1]</span>\n\n{{else if (or (eq metric \"pod-1\") (or (eq metric \"pod-5\") (eq metric \"pod-10\")))}}\nProbability of detection (POD) measures the fraction of observed rainfall events that were correctly predictedâ€”in this case, a weekly average daily rainfall of over 1, 5, or 10mm. We only calculate POD for precipitation. \\\n<span style=\"color: green; font-weight: bold;\">ðŸŸ¢ Larger is better â€” higher probability of detection is better. Range [0, 1]. </span>\n\n{{else if (or (eq metric \"far-1\") (or (eq metric \"far-5\") (eq metric \"far-10\")))}}\nFalse alarm rate (FAR) quantifies the fraction of predicted rainfall events that were not observedâ€”in this case, a weekly average daily rainfall of over 1, 5, or 10mm. We only calculate FAR for precipitation.\\ \n<span style=\"color: red; font-weight: bold;\">ðŸ”´ Smaller is better â€” lower false alarm rate is better. Range [0, 1].</span>\n\n{{else if (or (eq metric \"ets-1\") (or (eq metric \"ets-5\") (eq metric \"ets-10\")))}}\nEquitable threat score (ETS) measures a combination of POD and FAR while accounting for random chance on a specific eventâ€”in this case, a weekly average daily rainfall of over 1, 5, or 10mm. We only calculate ETS for precipitation. \\\n<span style=\"color: green; font-weight: bold;\">ðŸŸ¢ Larger is better â€” higher ETS indicates better skill. Range [-1/3, 1].</span>\n\n{{else}}\n_no description available for this metric._\n{{/if}}\n\n### Suitable Planting Window Model\nThis model approximates when a farmer in Kenya would be first be able to plant without incuring drought stress in the March-April-May (MAM) and October-November-December (OND) rainy seasons. This model is loosely adapted from the Suitable Planting Window model developed by John Corbett, an agricultural meterologist at TomorrowNow who has deployed planting advisories in Kenya in collaboration with KALRO.\n\nThis task defines the rainy season onsetâ€”in each year and for both the MAM and OND rainy seasonâ€”as the first date on which the following condition is satisfied:\n* **[Soil Wetness Condition]** To wet the soil to approximately a hand's depth, we require at least 30mm of rain over the next 8 days **and**  40mm of rain over the next 11 days\n* **[No Drought Condition]** To ensure that seeds have enough consistant rainfall to germinate then survive, we require that beyond Day 11, the next 11 days will have at least 15mm of rain.\n\n",
        "contentPartials": [],
        "defaultContent": "The query didn't return any results.",
        "editor": {
          "format": "auto",
          "language": "markdown"
        },
        "editors": [],
        "externalStyles": [],
        "helpers": "",
        "renderMode": "everyRow",
        "styles": "",
        "wrap": true
      },
      "pluginVersion": "5.6.0",
      "targets": [
        {
          "editorMode": "code",
          "format": "table",
          "rawQuery": true,
          "rawSql": "select '${metric}' as metric\n",
          "refId": "A",
          "sql": {
            "columns": [
              {
                "parameters": [],
                "type": "function"
              }
            ],
            "groupBy": [
              {
                "property": {
                  "type": "string"
                },
                "type": "groupBy"
              }
            ],
            "limit": 50
          }
        }
      ],
      "title": "",
      "transparent": true,
      "type": "marcusolsson-dynamictext-panel"
    },
    {
      "datasource": {
        "default": true,
        "type": "grafana-postgresql-datasource",
        "uid": "bdz3m3xs99p1cf"
      },
      "fieldConfig": {
        "defaults": {},
        "overrides": [
          {
            "matcher": {
              "id": "byName",
              "options": "forecast"
            },
            "properties": []
          },
          {
            "matcher": {
              "id": "byName",
              "options": "forecast"
            },
            "properties": []
          }
        ]
      },
      "gridPos": {
        "h": 7,
        "w": 14,
        "x": 0,
        "y": 8
      },
      "id": 11,
      "options": {
        "allData": {},
        "config": {},
        "data": [],
        "imgFormat": "png",
        "layout": {
          "font": {
            "family": "Inter, sans-serif"
          },
          "margin": {
            "b": 4,
            "l": 0,
            "r": 0,
            "t": 0
          },
          "paper_bgcolor": "#F4F5F5",
          "plog_bgcolor": "#F4F5F5",
          "title": {
            "automargin": true
          },
          "xaxis": {
            "automargin": true,
            "autorange": true,
            "type": "date"
          },
          "yaxis": {
            "automargin": true,
            "autorange": true
          }
        },
        "onclick": "",
        "resScale": 2,
        "script": "// Utility function to convert hex color to an RGB object\nfunction hexToRgb(hex) {\n    const bigint = parseInt(hex.slice(1), 16);\n    return {\n        r: (bigint >> 16) & 255,\n        g: (bigint >> 8) & 255,\n        b: bigint & 255\n    };\n}\n\n// Function to get interpolated color by passing a value from 0 to 1\nfunction getColor(value, cmin, cmax, colorMap) {\n    let colors;\n\n    // Define color scales based on the selected colormap\n    if (colorMap === 'BrBG') {\n        colors = [\n            \"#543005\",\n            \"#8C510A\", \"#BF812D\", \"#DFC27D\", \"#F6E8C3\",\n            \"#F5F5F5\", \"#C7EAE5\", \"#80CDC1\", \"#35978F\", \"#01665E\",\n            \"#003C30\"\n        ];\n    } else if (colorMap === 'balance') {\n        colors = [\n            \"#2a0a0a\",\n            \"#751b1b\", \"#b73c3c\", \"#e88484\", \"#f3c3c3\", // Negative side\n            \"#ffffff\",                                    // Neutral middle\n            \"#c3e4f3\", \"#84c2e8\", \"#3c9fb7\", \"#1b5e75\",  // Positive side\n            \"#0a2a2a\"\n        ];\n        colors = colors.reverse();\n    } else if (colorMap === 'RdBu') {\n        colors = ['#ff0000', '#ffffff', '#0000ff'];\n    } else {\n        throw new Error(\"Invalid colorMap. Choose 'BrBG', 'balance', or 'RdBu'.\");\n    }\n\n    let x;\n    if (value > 0) {\n        x = 0.5 + (value / cmax) * 0.5;  // Map positive values from 0.5 to 1.0\n    } else if (value < 0) {\n        x = 0.5 + (value / (-cmin)) * 0.5;  // Map negative values from 0.0 to 0.5\n    } else {\n        x = 0.5;  // Zero maps to middle\n    }\n\n    // Clamp value between 0 and 1\n    x = Math.min(1, Math.max(0, x));\n    if (isNaN(x)) {\n        return `rgba(255, 255, 255, 0.5)`;\n    }\n\n    // Compute exact position in color array\n    const scaledValue = x * (colors.length - 1);\n    const lowerIndex = Math.floor(scaledValue);\n    const upperIndex = Math.ceil(scaledValue);\n\n    // Edge case: if at the end of the array, return the last color\n    if (lowerIndex === upperIndex) {\n        const color = hexToRgb(colors[lowerIndex]);\n        return `rgba(${color.r}, ${color.g}, ${color.b}, 0.5)`;\n    }\n\n    // Interpolate between the two colors\n    const lowerColor = hexToRgb(colors[lowerIndex]);\n    const upperColor = hexToRgb(colors[upperIndex]);\n    const t = scaledValue - lowerIndex;\n\n    // Interpolate RGB channels\n    const r = Math.round(lowerColor.r + t * (upperColor.r - lowerColor.r));\n    const g = Math.round(lowerColor.g + t * (upperColor.g - lowerColor.g));\n    const b = Math.round(lowerColor.b + t * (upperColor.b - lowerColor.b));\n\n    return `rgba(${r}, ${g}, ${b}, 0.5)`;\n}\n\nlet series = data.series[0];\nif (series.length == 0) {\n    return {\n        data: []\n    };\n}\n\nlet forecasts = series.fields[0].values;\nlet values = [];\nlet skills = [];\nlet header = [\"Forecast\"];\nlet orig_header = [\"forecast\"];\nlet max = -Infinity;\nlet min = Infinity;\n\nlet skill_baseline_idx = null;\nfor (let i = 0; i < forecasts.length; i++) {\n    if (variables.baseline.current.value == forecasts[i]) {\n        skill_baseline_idx = i;\n    }\n}\n\nlet baseline_values = [];\nfor (let i = 1; i < series.fields.length; i++) {\n    baseline_values.push(series.fields[i].values[skill_baseline_idx]);\n}\n\nfor (let i = 1; i < series.fields.length; i++) {\n    let v = series.fields[i].values;\n    let skill_values = [];\n    for (let j = 0; j < v.length; j++) {\n        let val = parseFloat(v[j]);\n        if (val > max) {\n            max = val;\n        }\n        if (val < min) {\n            min = val;\n        }\n        const baselineVal = baseline_values[(i - 1)];\n        if (isNaN(baselineVal) || baselineVal === 0 || baselineVal == null) {\n            skill_values.push(null);\n        } else {\n            skill_values.push((1 - (val / baselineVal)));\n        }\n        // skill_values.push((1 - (val / baseline_values[(i - 2 - idx)])));\n    }\n    values.push(v);\n    skills.push(skill_values);\n    header.push(\"Week \" + (i));\n    orig_header.push(\"week\" + (i));\n}\nconsole.log(forecasts);\n\n// Round to two decimal places\nvalues = values.map((week) => week.map((x) => x ? x.toFixed(2) : '-'));\nforecasts = forecasts.map((forecast) =>\n    forecast.replace(/_/g, ' ')\n        .split(' ')\n        .map((word) => word[0].toUpperCase() + word.substring(1))\n        .join(' ')\n);\nvalues.unshift(forecasts);\n\n\n// Define a dictionary for custom renaming\nconst renameDict = {\n    \"Ecmwf Ifs Er\": \"ECMWF IFS ER\",\n    \"Ecmwf Ifs Er Debiased\": \"ECMWF IFS ER Debiased\",\n    \"Salient\": \"Salient\",\n    \"Fuxi\": \"FuXi S2S\"\n};\n\n// Apply custom renaming to the first column\nvalues[0] = values[0].map(value => renameDict[value] || value);\n\n// Assign the forecast colors\nlet forecast_colors = Array(forecasts.length).fill('rgba(0,0,0,0)');\n\nlet skill_colors = []\n// assign the skill colors\nlet colorMap, cmax, cmin;\n// Determine color map and ranges based on metric\nswitch (variables['metric'].current.value) {\n    case 'bias':\n        colorMap = 'BrBG';\n        [cmin, cmax] = [min, max];\n        break;\n    case 'acc':\n        colorMap = 'RdBu';\n        [cmin, cmax] = [-1, 1];\n        break;\n    // Error metrics - smaller is better\n    case 'mae':\n    case 'crps':\n    case 'rmse':\n    case 'smape':\n    case 'seeps':\n        colorMap = 'RdBu';\n        [cmin, cmax] = [-1, 1];\n        break;\n    // Skill score metrics - larger is better\n    case 'heidke-1-5-10-20':\n    case 'pod-1':\n    case 'pod-5':\n    case 'pod-10':\n    case 'ets-1':\n    case 'ets-5':\n    case 'ets-10':\n        colorMap = 'RdBu';\n        [cmin, cmax] = [-1, 1];\n        break;\n    // FAR metrics - smaller is better\n    case 'far-1':\n    case 'far-5':\n    case 'far-10':\n        colorMap = 'RdBu';\n        [cmin, cmax] = [-1, 1]\n        break;\n    default:\n        colorMap = 'RdBu';\n        [cmin, cmax] = [-1, 1];\n}\n\nfor (var i = 0; i < skills.length; i++) {\n    let week_colors = [];\n    for (var j = 0; j < skills[i].length; j++) {\n        if (variables['metric'].current.value == 'acc' || variables['metric'].current.value == 'bias') {\n            val = parseFloat(values[i + 1][j]);\n        } else {\n            val = parseFloat(skills[i][j]);\n        }\n        week_colors.push(getColor(val, cmin, cmax, colorMap))\n    }\n    skill_colors.push(week_colors)\n}\nreturn {\n    data: [{\n        type: 'table',\n        header: {\n            values: header,\n            align: ['left', 'right', 'right', 'right', 'right', 'right'],\n            line: { width: 0, color: '#DBDDDE' },\n            font: { family: \"Inter, sans-serif\", size: 14, weight: \"bold\" },\n            fill: {\n                color: ['rgba(0,0,0,0)']\n            }\n        },\n        cells: {\n            values: values,\n            align: ['left', 'right', 'right', 'right', 'right', 'right'],\n            line: { width: 1, color: \"#DBDDDE\" },\n            font: { family: \"Inter, sans-serif\", size: 14, color: [\"black\"] },\n            fill: {\n                color: [\n                    forecast_colors,\n                    ...skill_colors\n                ]\n            },\n            height: 35\n        },\n        columnwidth: [1.5, 0.8, 0.8, 0.8, 0.8, 0.8]\n    }]\n};",
        "syncTimeRange": false,
        "timeCol": ""
      },
      "pluginVersion": "1.8.2",
      "targets": [
        {
          "datasource": {
            "type": "grafana-postgresql-datasource",
            "uid": "bdz3m3xs99p1cf"
          },
          "editorMode": "code",
          "format": "table",
          "rawQuery": true,
          "rawSql": "SELECT\n   forecast,\n   CAST(day1 AS FLOAT) / (24 * 60 * 60) as day1,\n   CAST(day8 AS FLOAT) / (24 * 60 * 60) as day8,\n   CAST(day15 AS FLOAT) / (24 * 60 * 60) as day15,\n   CAST(day20 AS FLOAT) / (24 * 60 * 60) as day20\n   -- CASE WHEN \"$task\" = 'rainy_onset' THEN CAST(day22 AS FLOAT) / (24 * 60 * 60) END as day22,\n   -- CASE WHEN \"$task\" = 'rainy_onset' THEN CAST(day29 AS FLOAT) / (24 * 60 * 60) END as day29,\n   -- CASE WHEN \"$task\" = 'rainy_onset' THEN CAST(day36 AS FLOAT) / (24 * 60 * 60) END as day36\nFROM \"$metrics_tab_name\";\n\n-- SELECT \n--    forecast,\n--    CAST(day1 AS FLOAT) / (24 * 60 * 60) as day1,\n--    CAST(day8 AS FLOAT) / (24 * 60 * 60) as day8,\n--    CAST(day15 AS FLOAT) / (24 * 60 * 60) as day15,\n--    CAST(day22 AS FLOAT) / (24 * 60 * 60) as day22,\n--    CAST(day29 AS FLOAT) / (24 * 60 * 60) as day29,\n--    CAST(day36 AS FLOAT) / (24 * 60 * 60) as day36\n-- FROM \"$metrics_tab_name\";\n",
          "refId": "A",
          "sql": {
            "columns": [
              {
                "parameters": [],
                "type": "function"
              }
            ],
            "groupBy": [
              {
                "property": {
                  "type": "string"
                },
                "type": "groupBy"
              }
            ],
            "limit": 50
          }
        },
        {
          "datasource": {
            "type": "grafana-postgresql-datasource",
            "uid": "bdz3m3xs99p1cf"
          },
          "editorMode": "code",
          "format": "table",
          "hide": false,
          "rawQuery": true,
          "rawSql": "select '${baseline}'",
          "refId": "B",
          "sql": {
            "columns": [
              {
                "parameters": [],
                "type": "function"
              }
            ],
            "groupBy": [
              {
                "property": {
                  "type": "string"
                },
                "type": "groupBy"
              }
            ],
            "limit": 50
          }
        }
      ],
      "title": "${region} Suitable Planting Window Forecast Error (days)",
      "transparent": true,
      "type": "nline-plotlyjs-panel"
    },
    {
      "datasource": {
        "default": true,
        "type": "grafana-postgresql-datasource",
        "uid": "bdz3m3xs99p1cf"
      },
      "fieldConfig": {
        "defaults": {},
        "overrides": [
          {
            "matcher": {
              "id": "byName",
              "options": "forecast"
            },
            "properties": []
          },
          {
            "matcher": {
              "id": "byName",
              "options": "forecast"
            },
            "properties": []
          }
        ]
      },
      "gridPos": {
        "h": 7,
        "w": 9,
        "x": 15,
        "y": 8
      },
      "id": 12,
      "options": {
        "allData": {},
        "config": {},
        "data": [],
        "imgFormat": "png",
        "layout": {
          "font": {
            "family": "Inter, sans-serif"
          },
          "margin": {
            "b": 0,
            "l": 0,
            "r": 0,
            "t": 0
          },
          "paper_bgcolor": "#F4F5F5",
          "plog_bgcolor": "#F4F5F5",
          "title": {
            "automargin": true
          },
          "xaxis": {
            "automargin": true,
            "autorange": true,
            "type": "date"
          },
          "yaxis": {
            "automargin": true,
            "autorange": true
          }
        },
        "onclick": "",
        "resScale": 0,
        "script": "let series = data.series[0]\nif (series.length == 0) {\n    return {\n        data: []\n    }\n}\n\nidx = 0\nforecasts = series.fields[1 + idx].values\nvalues = []\nskills = []\nheader = [\"Rainfall Ground Truth\", \"Onset Difference\"]\norig_header = [\"forecast\", \"daily\"]\n\nfor (var i = 2 + idx; i < series.fields.length; i = i + 1) {\n    v = series.fields[i].values\n    values.push(v)\n}\n\n// round to two decimal places\nvalues = values.map((week) => week.map((x) => { if (x) { return x.toFixed(2) } else { return '-' } }))\nforecasts = forecasts.map((forecast) => forecast.replaceAll('_', ' ').split(' ').map((word) => word[0].toUpperCase() + word.substring(1)).join(' '))\nvalues.unshift(forecasts)\n\n// Rename dictionary\nconst renameDict = {\n    \"Chirps\": \"CHIRPS\",\n    \"Era5\": \"ERA5\",\n    \"Imerg\": \"IMERG\",\n    \"Cbam\": \"CBAM\",\n    \"Ghcn\": \"GHCN\",\n    \"Tahmo\": \"TAHMO\"\n};\n\n// Apply custom renaming to the first column of cellValues\nvalues[0] = values[0].map(value => renameDict[value] || value);\nreturn {\n    data: [{\n        type: 'table',\n        header: {\n            values: header,\n            align: ['left', 'right', 'right', 'right', 'right'],\n            line: { width: 0, color: '#DBDDDE' },\n            font: { family: \"Inter, sans-serif\", size: 14, weight: \"bold\" },\n            fill: {\n                color: ['rgba(0,0,0,0)']\n            }\n        },\n        cells: {\n            values: values,\n            align: ['left', 'right',  'right', 'right', 'right'],\n            line: { width: 1, color: \"#DBDDDE\" },\n            font: { family: \"Inter, sans-serif\", size: 14, color: [\"black\"] },\n            fill: {\n                // color: [forecast_colors, ...skill_colors]\n                color: ['rgba(0,0,0,0)']\n\n            },\n            height: 35\n        },\n        columnwidth: [0.5, 0.5] // Make divider column very thin\n    }]\n}\n",
        "syncTimeRange": false,
        "timeCol": ""
      },
      "pluginVersion": "1.8.2",
      "targets": [
        {
          "datasource": {
            "type": "grafana-postgresql-datasource",
            "uid": "bdz3m3xs99p1cf"
          },
          "editorMode": "code",
          "format": "table",
          "rawQuery": true,
          "rawSql": "SELECT\n   index,\n   forecast,\n   CAST(daily AS FLOAT) / (24 * 60 * 60) as daily\nFROM \"$station_metrics_tab_name\";",
          "refId": "A",
          "sql": {
            "columns": [
              {
                "parameters": [],
                "type": "function"
              }
            ],
            "groupBy": [
              {
                "property": {
                  "type": "string"
                },
                "type": "groupBy"
              }
            ],
            "limit": 50
          }
        },
        {
          "datasource": {
            "type": "grafana-postgresql-datasource",
            "uid": "bdz3m3xs99p1cf"
          },
          "editorMode": "code",
          "format": "table",
          "hide": false,
          "rawQuery": true,
          "rawSql": "-- select '${baseline}'",
          "refId": "B",
          "sql": {
            "columns": [
              {
                "parameters": [],
                "type": "function"
              }
            ],
            "groupBy": [
              {
                "property": {
                  "type": "string"
                },
                "type": "groupBy"
              }
            ],
            "limit": 50
          }
        }
      ],
      "title": "${region} Suitable Planting Window Ground Truth Variability (days)",
      "transparent": true,
      "type": "nline-plotlyjs-panel"
    },
    {
      "datasource": {
        "uid": "bdz3m3xs99p1cf"
      },
      "fieldConfig": {
        "defaults": {
          "thresholds": {
            "mode": "absolute",
            "steps": [
              {
                "color": "green",
                "value": null
              },
              {
                "color": "red",
                "value": 80
              }
            ]
          }
        },
        "overrides": []
      },
      "gridPos": {
        "h": 2,
        "w": 24,
        "x": 0,
        "y": 15
      },
      "id": 14,
      "options": {
        "afterRender": "// window.onload = function () {\n//     renderMathInElement(document.body, {\n//         delimiters: [\n//             { left: \"$$\", right: \"$$\", display: true },\n//             { left: \"\\\\(\", right: \"\\\\)\", display: false }\n//         ]\n//     });\n// };\n",
        "content": "Note: missing data and unflagged low rainfall values in the GHCN and TAHMO station data appear to have a significant impact on rainy season onset detection. Take the station comparison with a grain of salt.",
        "contentPartials": [],
        "defaultContent": "The query didn't return any results.",
        "editor": {
          "format": "auto",
          "language": "markdown"
        },
        "editors": [],
        "externalStyles": [],
        "helpers": "",
        "renderMode": "everyRow",
        "styles": "",
        "wrap": true
      },
      "pluginVersion": "5.6.0",
      "targets": [
        {
          "editorMode": "code",
          "format": "table",
          "rawQuery": true,
          "rawSql": "select '${metric}' as metric\n",
          "refId": "A",
          "sql": {
            "columns": [
              {
                "parameters": [],
                "type": "function"
              }
            ],
            "groupBy": [
              {
                "property": {
                  "type": "string"
                },
                "type": "groupBy"
              }
            ],
            "limit": 50
          }
        }
      ],
      "title": "",
      "transparent": true,
      "type": "marcusolsson-dynamictext-panel"
    }
  ],
  "preload": false,
  "refresh": "",
  "schemaVersion": 40,
  "tags": [],
  "templating": {
    "list": [
      {
        "current": {
          "text": "mae",
          "value": "mae"
        },
        "includeAll": false,
        "label": "Metric",
        "name": "metric",
        "options": [
          {
            "selected": true,
            "text": "MAE",
            "value": "mae"
          },
          {
            "selected": false,
            "text": "Bias",
            "value": "bias"
          },
          {
            "selected": false,
            "text": "RMSE",
            "value": "rmse"
          }
        ],
        "query": "MAE : mae, Bias : bias, RMSE : rmse",
        "type": "custom"
      },
      {
        "current": {
          "text": "climatology_2015",
          "value": "climatology_2015"
        },
        "includeAll": false,
        "label": "Baseline",
        "name": "baseline",
        "options": [
          {
            "selected": false,
            "text": "FuXi",
            "value": "fuxi"
          },
          {
            "selected": false,
            "text": "ECMWF IFS ER",
            "value": "ecmwf_ifs_er"
          },
          {
            "selected": false,
            "text": "ECMWF IFS ER Debiased",
            "value": "ecmwf_ifs_er_debiased"
          },
          {
            "selected": true,
            "text": "Clim 1985-2014",
            "value": "climatology_2015"
          }
        ],
        "query": "FuXi : fuxi, ECMWF IFS ER : ecmwf_ifs_er, ECMWF IFS ER Debiased : ecmwf_ifs_er_debiased, Clim 1985-2014 : climatology_2015",
        "type": "custom"
      },
      {
        "current": {
          "text": "ghcn",
          "value": "ghcn"
        },
        "includeAll": false,
        "label": "Ground Truth",
        "name": "truth",
        "options": [
          {
            "selected": false,
            "text": "ERA5",
            "value": "era5"
          },
          {
            "selected": false,
            "text": "IMERG",
            "value": "imerg"
          },
          {
            "selected": true,
            "text": "GHCN",
            "value": "ghcn"
          },
          {
            "selected": false,
            "text": "CHIRPS",
            "value": "chirps"
          },
          {
            "selected": false,
            "text": "TAHMO",
            "value": "tahmo"
          }
        ],
        "query": "ERA5 : era5, IMERG : imerg, GHCN : ghcn, CHIRPS : chirps, TAHMO : tahmo",
        "type": "custom"
      },
      {
        "current": {
          "text": "global1_5",
          "value": "global1_5"
        },
        "includeAll": false,
        "label": "Grid",
        "name": "grid",
        "options": [
          {
            "selected": true,
            "text": "1.5",
            "value": "global1_5"
          }
        ],
        "query": "1.5 : global1_5",
        "type": "custom"
      },
      {
        "current": {
          "text": "kenya",
          "value": "kenya"
        },
        "hide": 2,
        "includeAll": false,
        "label": "Region",
        "name": "region",
        "options": [
          {
            "selected": true,
            "text": "Kenya",
            "value": "kenya"
          }
        ],
        "query": "Kenya : kenya",
        "type": "custom"
      },
      {
        "current": {
          "text": "ed363913edad1cf57b856897e95840fe",
          "value": "ed363913edad1cf57b856897e95840fe"
        },
        "datasource": {
          "type": "grafana-postgresql-datasource",
          "uid": "bdz3m3xs99p1cf"
        },
        "definition": "select * from md5('summary_metrics_table/2022-12-31_${grid}_lsm_${metric}_${region}_2016-01-01_None_${truth}_${task}')",
        "hide": 2,
        "includeAll": false,
        "name": "metrics_tab_name",
        "options": [],
        "query": "select * from md5('summary_metrics_table/2022-12-31_${grid}_lsm_${metric}_${region}_2016-01-01_None_${truth}_${task}')",
        "refresh": 2,
        "regex": "",
        "type": "query"
      },
      {
        "current": {
          "text": "fa9345f0d3772f5a4d4500e6991a3e79",
          "value": "fa9345f0d3772f5a4d4500e6991a3e79"
        },
        "datasource": {
          "type": "grafana-postgresql-datasource",
          "uid": "bdz3m3xs99p1cf"
        },
        "definition": "select * from md5('station_metrics_table/2022-12-31_${grid}_lsm_${metric}_${region}_2016-01-01_None_${truth}_${task}')",
        "hide": 2,
        "includeAll": false,
        "name": "station_metrics_tab_name",
        "options": [],
        "query": "select * from md5('station_metrics_table/2022-12-31_${grid}_lsm_${metric}_${region}_2016-01-01_None_${truth}_${task}')",
        "refresh": 2,
        "regex": "",
        "type": "query"
      },
      {
        "current": {
          "text": "rainy_onset_no_drought",
          "value": "rainy_onset_no_drought"
        },
        "hide": 2,
        "includeAll": false,
        "label": "Task",
        "name": "task",
        "options": [
          {
            "selected": true,
            "text": "Rainy Onset",
            "value": "rainy_onset_no_drought"
          }
        ],
        "query": "Rainy Onset : rainy_onset_no_drought",
        "type": "custom"
      }
    ]
  },
  "time": {
    "from": "now-6h",
    "to": "now"
  },
  "timepicker": {
    "hidden": true
  },
  "timezone": "utc",
  "title": "Kenya Suitable Planting Window",
  "uid": "dea0hyle4eby8c",
  "version": 233,
  "weekStart": ""
}
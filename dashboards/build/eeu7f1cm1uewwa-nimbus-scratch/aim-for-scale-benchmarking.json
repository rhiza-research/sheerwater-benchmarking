{
  "annotations": {
    "list": [
      {
        "builtIn": 1,
        "datasource": {
          "type": "grafana",
          "uid": "-- Grafana --"
        },
        "enable": true,
        "hide": true,
        "iconColor": "rgba(0, 211, 255, 1)",
        "name": "Annotations & Alerts",
        "type": "dashboard"
      }
    ]
  },
  "editable": true,
  "fiscalYearStartMonth": 0,
  "graphTooltip": 0,
  "id": 51,
  "links": [],
  "panels": [
    {
      "datasource": {
        "uid": "bdz3m3xs99p1cf"
      },
      "fieldConfig": {
        "defaults": {
          "thresholds": {
            "mode": "absolute",
            "steps": [
              {
                "color": "green",
                "value": null
              },
              {
                "color": "red",
                "value": 80
              }
            ]
          }
        },
        "overrides": []
      },
      "gridPos": {
        "h": 4,
        "w": 24,
        "x": 0,
        "y": 0
      },
      "id": 5,
      "options": {
        "afterRender": "// window.onload = function () {\n//     renderMathInElement(document.body, {\n//         delimiters: [\n//             { left: \"$$\", right: \"$$\", display: true },\n//             { left: \"\\\\(\", right: \"\\\\)\", display: false }\n//         ]\n//     });\n// };\n",
        "content": "### Selected Metric: {{#if (eq metric \"mae\")}}MAE {{/if}} {{#if (eq metric \"rmse\")}}RMSE{{/if}} {{#if (eq metric \"crps\")}}CRPS{{/if}} {{#if (eq metric \"bias\")}}Bias{{/if}} {{#if (eq metric \"smape\")}}SMAPE{{/if}} {{#if (eq metric \"seeps\")}}SEEPS{{/if}} {{#if (eq metric \"acc\")}}ACC{{/if}}  {{#if (eq metric \"heidke-1-5-10-20\")}}Heidke 1/5/10/20mm{{/if}} {{#if (eq metric \"far-1\")}}FAR 1mm{{/if}} {{#if (eq metric \"far-5\")}}FAR 5mm{{/if}} {{#if (eq metric \"far-10\")}}FAR 10mm{{/if}} {{#if (eq metric \"pod-1\")}}POD 1mm{{/if}} {{#if (eq metric \"pod-5\")}}POD 5mm{{/if}} {{#if (eq metric \"pod-10\")}}POD 10mm{{/if}} {{#if (eq metric \"ets-1\")}}ETS 1mm{{/if}} {{#if (eq metric \"ets-5\")}}ETS 5mm{{/if}} {{#if (eq metric \"ets-10\")}}ETS 10mm{{/if}}\n\n{{#if (eq metric \"mae\")}}\nMean absolute error (MAE) measures the average magnitude of the errors in a set of predictions, without considering\ntheir direction.\\\n<span style=\"color: red; font-weight: bold;\">ðŸ”´ Smaller is better â€” lower MAE means better predictions.</span> \n\n{{else if (eq metric \"crps\")}}\nContinuous ranked probability score (CRPS) assesses the accuracy of probabilistic forecasts by comparing the cumulative\ndistribution function of forecasts to the observed values.\\\n<span style=\"color: red; font-weight: bold;\">ðŸ”´ Smaller is better â€” lower CRPS indicates better probabilistic forecasting skill.</span>\n\n{{else if (eq metric \"rmse\")}}\nRoot mean squared error (RMSE) gives higher weight to large errors, making it more sensitive to outliers.\\\n<span style=\"color: red; font-weight: bold;\">ðŸ”´ Smaller is better â€” lower RMSE means better predictions.</span>\n\n{{else if (eq metric \"acc\")}}\nAnomaly correlation coefficient (ACC) ACC is a measure of how well the forecast anomalies have represented the observed anomalies\nrelative to climatology. We used 1991-2020 climatology (years inclusive) for our ACC calculation.\\\n<span style=\"color: green; font-weight: bold;\">ðŸŸ¢ Larger is better â€” higher ACC means better predictions. Range [-1, 1].</span>\n\n{{else if (eq metric \"bias\")}}\nBias measures the signed magnitude of errors in a set of predictions. \\\n<span style=\"color: gray; font-weight: bold;\">âšª Ideal value = 0.0 â€” Bias should be close to 0.0 for an unbiased forecast.</span>\n\n{{else if (eq metric \"smape\")}}\nSymmetric mean absolute percentage error (SMAPE) is a normalized version of Mean Absolute Percentage Error (MAPE) and calculate sthe error as a percentage of the total value. We only calculate SMAPE for precipitation.\\\n<span style=\"color: red; font-weight: bold;\">ðŸ”´ Smaller is better â€” lower SMAPE indicates better forecasting accuracy. Range [0, 1].</span>\n\n{{else if (eq metric \"seeps\")}}\nStable equitable error in probability space (SEEPS) is a score designed for evaluating rainfall forecasts while taking into account climactic difference in rainfall. Areas that are too dry or wet are exclued. \nWe include all cells with a 3-93% non-dry day frequency to ensure inclusion of relevant parts of Africa. We only calculate SEEPS for precipitation.\\\n<span style=\"color: red; font-weight: bold;\">ðŸ”´ Smaller is better â€” lower SEEPS indicates better forecasting accuracy. Good SEEPS for short term forecasts on cells that have 10-85% non-dry days are considered between 0-1.</span>\n\n{{else if (eq metric \"heidke-1-5-10-20\")}}\nHeidke skill score (HSS) compares the accuracy of a forecast to random chance for a set of predetermined rainfall thresholdsâ€”in this case, 1, 5, 10, and 20mm. We only calculate Heidke for precipitation.\\\n<span style=\"color: green; font-weight: bold;\">ðŸŸ¢ Larger is better â€” a higher HSS indicates better skill. Range [-&infin;, 1]</span>\n\n{{else if (or (eq metric \"pod-1\") (or (eq metric \"pod-5\") (eq metric \"pod-10\")))}}\nProbability of detection (POD) measures the fraction of observed rainfall events that were correctly predictedâ€”in this case, a weekly average daily rainfall of over 1, 5, or 10mm. We only calculate POD for precipitation. \\\n<span style=\"color: green; font-weight: bold;\">ðŸŸ¢ Larger is better â€” higher probability of detection is better. Range [0, 1]. </span>\n\n{{else if (or (eq metric \"far-1\") (or (eq metric \"far-5\") (eq metric \"far-10\")))}}\nFalse alarm rate (FAR) quantifies the fraction of predicted rainfall events that were not observedâ€”in this case, a weekly average daily rainfall of over 1, 5, or 10mm. We only calculate FAR for precipitation.\\ \n<span style=\"color: red; font-weight: bold;\">ðŸ”´ Smaller is better â€” lower false alarm rate is better. Range [0, 1].</span>\n\n{{else if (or (eq metric \"ets-1\") (or (eq metric \"ets-5\") (eq metric \"ets-10\")))}}\nEquitable threat score (ETS) measures a combination of POD and FAR while accounting for random chance on a specific eventâ€”in this case, a weekly average daily rainfall of over 1, 5, or 10mm. We only calculate ETS for precipitation. \\\n<span style=\"color: green; font-weight: bold;\">ðŸŸ¢ Larger is better â€” higher ETS indicates better skill. Range [-1/3, 1].</span>\n\n{{else}}\n_no description available for this metric._\n{{/if}}\n",
        "contentPartials": [],
        "defaultContent": "The query didn't return any results.",
        "editor": {
          "format": "auto",
          "language": "markdown"
        },
        "editors": [],
        "externalStyles": [],
        "helpers": "",
        "renderMode": "everyRow",
        "styles": "",
        "wrap": true
      },
      "pluginVersion": "5.6.0",
      "targets": [
        {
          "editorMode": "code",
          "format": "table",
          "rawQuery": true,
          "rawSql": "select '${metric}' as metric\n",
          "refId": "A",
          "sql": {
            "columns": [
              {
                "parameters": [],
                "type": "function"
              }
            ],
            "groupBy": [
              {
                "property": {
                  "type": "string"
                },
                "type": "groupBy"
              }
            ],
            "limit": 50
          }
        }
      ],
      "title": "",
      "transparent": true,
      "type": "marcusolsson-dynamictext-panel"
    },
    {
      "collapsed": true,
      "gridPos": {
        "h": 1,
        "w": 24,
        "x": 0,
        "y": 4
      },
      "id": 7,
      "panels": [
        {
          "datasource": {
            "uid": "bdz3m3xs99p1cf"
          },
          "fieldConfig": {
            "defaults": {
              "thresholds": {
                "mode": "absolute",
                "steps": [
                  {
                    "color": "green"
                  },
                  {
                    "color": "red",
                    "value": 80
                  }
                ]
              }
            },
            "overrides": []
          },
          "gridPos": {
            "h": 12,
            "w": 24,
            "x": 0,
            "y": 5
          },
          "id": 8,
          "options": {
            "afterRender": "// window.onload = function () {\n//     renderMathInElement(document.body, {\n//         delimiters: [\n//             { left: \"$$\", right: \"$$\", display: true },\n//             { left: \"\\\\(\", right: \"\\\\)\", display: false }\n//         ]\n//     });\n// };\n",
            "content": " - Models are evaluated from 2016-01-01 through 2022-12-31\n - All metrics are computed with the ECMWF land-sea mask that includes any cell with non-zero land coverage. \n - Spatial averages use latitude-based weighting.\n\n - Conservative regridding is used for both upscaling and downscaling forecasts. \n \n - ECMWF and FuXi S2S forecasts are native 1.5x1.5. \n \n - Salient, Graphcast, and Gencast are native 0.25x0.25.\n\n - Salient is conservatively regridded from their native 0.125 shifted grid to our round 0.25/1.5 grid. \n\n - All metrics are computed deterministically except for CRPS\n\n - Deterministic forecasts are derived from ensemble forecasts (ECMWF, FuXi, Gencast) through taking the average of the ensemble members\n\n - Deterministic forecasts are derived from quantile forecasts (Salient) by taking the median quantile.\n\n - The source for Gencast temperature forecasts was corrupted so they have been excluded.\n\n - Metrics that cannot be globally computed and then reduced (such as ACC, POD, FAR, ETC) are not available with time groupings.",
            "contentPartials": [],
            "defaultContent": "The query didn't return any results.",
            "editor": {
              "format": "auto",
              "language": "markdown"
            },
            "editors": [],
            "externalStyles": [],
            "helpers": "",
            "renderMode": "everyRow",
            "styles": "",
            "wrap": true
          },
          "pluginVersion": "5.6.0",
          "targets": [
            {
              "editorMode": "code",
              "format": "table",
              "rawQuery": true,
              "rawSql": "select '${metric}' as metric\n",
              "refId": "A",
              "sql": {
                "columns": [
                  {
                    "parameters": [],
                    "type": "function"
                  }
                ],
                "groupBy": [
                  {
                    "property": {
                      "type": "string"
                    },
                    "type": "groupBy"
                  }
                ],
                "limit": 50
              }
            }
          ],
          "title": "",
          "transparent": true,
          "type": "marcusolsson-dynamictext-panel"
        }
      ],
      "title": "Notes and Caveats",
      "type": "row"
    },
    {
      "collapsed": false,
      "gridPos": {
        "h": 1,
        "w": 24,
        "x": 0,
        "y": 5
      },
      "id": 9,
      "panels": [],
      "title": "Metrics",
      "type": "row"
    },
    {
      "datasource": {
        "default": true,
        "type": "grafana-postgresql-datasource",
        "uid": "bdz3m3xs99p1cf"
      },
      "fieldConfig": {
        "defaults": {},
        "overrides": [
          {
            "matcher": {
              "id": "byName",
              "options": "forecast"
            },
            "properties": []
          },
          {
            "matcher": {
              "id": "byName",
              "options": "forecast"
            },
            "properties": []
          }
        ]
      },
      "gridPos": {
        "h": 12,
        "w": 12,
        "x": 0,
        "y": 6
      },
      "id": 1,
      "options": {
        "allData": {},
        "config": {},
        "data": [],
        "imgFormat": "png",
        "layout": {
          "font": {
            "family": "Inter, sans-serif"
          },
          "margin": {
            "b": 4,
            "l": 0,
            "r": 0,
            "t": 0
          },
          "paper_bgcolor": "#F4F5F5",
          "plog_bgcolor": "#F4F5F5",
          "title": {
            "align": "left",
            "automargin": true,
            "font": {
              "color": "black",
              "family": "Inter, sans-serif",
              "size": 14,
              "weight": 500
            },
            "pad": {
              "b": 30
            },
            "text": "Weekly",
            "x": 0,
            "xanchor": "left"
          },
          "xaxis": {
            "automargin": true,
            "autorange": true,
            "type": "date"
          },
          "yaxis": {
            "automargin": true,
            "autorange": true
          }
        },
        "onclick": "",
        "resScale": 2,
        "script": "// Utility function to convert hex color to an RGB object\nfunction hexToRgb(hex) {\n    const bigint = parseInt(hex.slice(1), 16);\n    return {\n        r: (bigint >> 16) & 255,\n        g: (bigint >> 8) & 255,\n        b: bigint & 255\n    };\n}\n\n// Function to get interpolated color by passing a value from 0 to 1\nfunction getColor(value, cmin, cmax, colorMap) {\n    let colors;\n\n    // Define color scales based on the selected colormap\n    if (colorMap === 'BrBG') {\n        colors = [\n            \"#543005\",\n            \"#8C510A\", \"#BF812D\", \"#DFC27D\", \"#F6E8C3\",\n            \"#F5F5F5\", \"#C7EAE5\", \"#80CDC1\", \"#35978F\", \"#01665E\",\n            \"#003C30\"\n        ];\n    } else if (colorMap === 'balance') {\n        colors = [\n            \"#2a0a0a\",\n            \"#751b1b\", \"#b73c3c\", \"#e88484\", \"#f3c3c3\", // Negative side\n            \"#ffffff\",                                            // Neutral middle\n            \"#c3e4f3\", \"#84c2e8\", \"#3c9fb7\", \"#1b5e75\",  // Positive side\n            \"#0a2a2a\"\n        ];\n        colors = colors.reverse()\n    } else if (colorMap === 'RdBu') {\n        colors = ['#ff0000', '#ffffff', '#0000ff'];\n    } else if (colorMap === 'BuRd') {\n        colors = ['#0000ff', '#ffffff', '#ff0000'];        \n    } else {\n        throw new Error(\"Invalid colorMap. Choose 'BrBG', 'balance', or 'RdBu'.\");\n    }\n\n    let x;\n    if (value > 0) {\n        x = 0.5 + (value / cmax) * 0.5;  // Map positive values from 0.5 to 1.0\n    } else if (value < 0) {\n        x = 0.5 + (value / (-cmin)) * 0.5;  // Map negative values from 0.0 to 0.5\n    } else {\n        x = 0.5;  // Zero maps to middle\n    }    \n\n    // Clamp value between 0 and 1\n    x = Math.min(1, Math.max(0, x));\n    if (isNaN(x)) {\n        return `rgba(255, 255, 255, 0.5)`;\n    }\n\n    // Compute exact position in color array\n    const scaledValue = x * (colors.length - 1);\n    const lowerIndex = Math.floor(scaledValue);\n    const upperIndex = Math.ceil(scaledValue);\n\n    // Edge case: if at the end of the array, return the last color\n    if (lowerIndex === upperIndex) {\n        const color = hexToRgb(colors[lowerIndex]);\n        return `rgba(${color.r}, ${color.g}, ${color.b}, 0.5)`;\n    }\n\n    // Interpolate between the two colors\n    const lowerColor = hexToRgb(colors[lowerIndex]);\n    const upperColor = hexToRgb(colors[upperIndex]);\n    const t = scaledValue - lowerIndex;\n\n    // Interpolate RGB channels\n    const r = Math.round(lowerColor.r + t * (upperColor.r - lowerColor.r));\n    const g = Math.round(lowerColor.g + t * (upperColor.g - lowerColor.g));\n    const b = Math.round(lowerColor.b + t * (upperColor.b - lowerColor.b));\n\n    // Return the interpolated color as an rgb(r, g, b) string\n    return `rgba(${r}, ${g}, ${b}, 0.5)`;\n}\n\nlet series = data.series[0]\nif (series.length == 0) {\n    return {\n        data: []\n    }\n}\n\nif (variables.time_grouping.current.value != 'None') {\n    idx = 1\n} else {\n    idx = 0\n}\nforecasts = series.fields[1 + idx].values\nvalues = []\nskills = []\nheader = [\"Forecast\"]\norig_header = [\"forecast\"]\nlet max = -Infinity;\nlet min = Infinity;\n\nskill_baseline_idx = null;\nfor (var i = 0; i < forecasts.length; i = i + 1) {\n    if (variables.baseline.current.value == forecasts[i]) {\n        skill_baseline_idx = i\n    }\n}\n\nbaseline_values = []\nfor (var i = 2 + idx; i < series.fields.length; i = i + 1) {\n    baseline_values.push(series.fields[i].values[skill_baseline_idx])\n}\n\nfor (var i = 2 + idx; i < series.fields.length; i = i + 1) {\n    v = series.fields[i].values\n    skill_values = []\n    for (var j = 0; j < v.length; j++) {\n        let val = parseFloat(v[j]);\n        if (val > max) {\n            max = val;\n        }\n        if (val < min) {\n            min = val;\n        }\n        skill_values.push((1 - (val / baseline_values[(i - 2 - idx)])))\n    }\n    values.push(v)\n    skills.push(skill_values)\n    header.push(\"Week \" + (i - 1 - idx))\n    orig_header.push(\"week\" + (i - 1 - idx))\n}\n\nconsole.log(skills)\n\n// round to two decimal places\nvalues = values.map((week) => week.map((x) => { if (x) { return x.toFixed(2) } else { return '-' } }))\nforecasts = forecasts.map((forecast) => forecast.replaceAll('_', ' ').split(' ').map((word) => word[0].toUpperCase() + word.substring(1)).join(' '))\nvalues.unshift(forecasts)\n\n// Define a dictionary for custom renaming\nconst renameDict = {\n    \"Ecmwf Ifs Er\": \"ECMWF IFS ER\",\n    \"Ecmwf Ifs Er Debiased\": \"ECMWF IFS ER Debiased\",\n    \"Salient\": \"Salient\",\n    \"Fuxi\": \"FuXi S2S\",\n    \"Climatology 2015\": \"Climatology 1985-2014\",\n    \"Climatology Trend 2015\": \"Climatology 1985-2014 w/Trend\"\n};\n\n// Apply custom renaming to the first column of cellValues\nvalues[0] = values[0].map(value => renameDict[value] || value);\n\n// assign the forecast colors\nforecast_colors = []\nfor (var i = 0; i < forecasts.length; i++) {\n    forecast_colors.push('rgba(0,0,0,0)')\n}\n\nlet skill_colors = []\n// assign the skill colors\nlet colorMap, cmax, cmin;\n// if (variables['metric'].current.value == 'bias') {\n//     colormap = 'balance';\n//     cmax = max;\n//     cmin = min;\n// }\n// else {\n//     colormap = 'rdbu';\n//     cmax = 1;\n//     cmin = -1;\n// }\n// Determine color map and ranges based on metric\nswitch (variables['metric'].current.value) {\n    case 'bias':\n        colorMap = 'BuRd';\n        [cmin, cmax] = [min, max];\n        break;\n    case 'acc':\n        colorMap = 'RdBu';\n        [cmin, cmax] = [-1, 1];\n        break;\n    // Error metrics - smaller is better\n    case 'mae':\n    case 'crps':\n    case 'rmse':\n    case 'smape':\n    case 'seeps':\n        colorMap = 'RdBu';\n        [cmin, cmax] = [-1, 1];\n        break;\n    // Skill score metrics - larger is better\n    case 'heidke-1-5-10-20':\n    case 'pod-1':\n    case 'pod-5':\n    case 'pod-10':\n    case 'ets-1':\n    case 'ets-5':\n    case 'ets-10':\n        colorMap = 'RdBu';\n        [cmin, cmax] = [0, 1];\n        break;\n    // FAR metrics - smaller is better\n    case 'far-1':\n    case 'far-5':\n    case 'far-10':\n        colorMap = 'RdBu';\n        [cmin, cmax] = [0, 1];\n        break;\n    default:\n        colorMap = 'RdBu';\n        [cmax, cmin] = [1, -1];\n}\n\nfor (var i = 0; i < skills.length; i++) {\n    let week_colors = [];\n    for (var j = 0; j < skills[i].length; j++) {\n        if (variables['metric'].current.value == 'acc' || variables['metric'].current.value == 'bias') {\n            val = parseFloat(values[i + 1][j]);\n        } else {\n            val = parseFloat(skills[i][j]);\n        }\n        week_colors.push(getColor(val, cmin, cmax, colorMap))\n    }\n    skill_colors.push(week_colors)\n}\n\n// Turn the metrics into links\norig_forecasts = series.fields[1 + idx].values\nmetric = variables.metric.current.value\ngrid = variables.grid.current.value\nregion = variables.region.current.value\ntime_grouping = variables.time_grouping.current.value\ntime_filter = variables.time_filter.current.value\nfor (var i = 1; i < values.length; i++) {\n    for (var j = 0; j < values[i].length; j++) {\n        url = `/d/ae39q2k3jv668d/plotly-maps?orgId=1&var-forecast=${orig_forecasts[j]}&var-metric=${metric}&var-lead=${orig_header[i]}&var-truth=era5&var-grid=${grid}&var-region=${region}&var-time_grouping=${time_grouping}&var-time_filter=${time_filter}`\n        values[i][j] = `<a href=\"${url}\">` + values[i][j] + '</a>'\n    }\n}\n\nvar units = \"\"\nif (metric == 'mae' || metric == 'bias' || metric == 'crps' || metric == 'rmse') {\n    units = \" (C)\"\n}\n\nreturn {\n    data: [{\n        type: 'table',\n        header: {\n            values: [...header.slice(0, 3), '', ...header.slice(3)], // Add empty column for divider\n            align: ['left', 'right', 'right', 'right', 'right', 'right'],\n            line: { width: 0, color: '#DBDDDE' },\n            font: { family: \"Inter, sans-serif\", size: 14, weight: \"bold\" },\n            fill: {\n                color: ['rgba(0,0,0,0)']\n            }\n        },\n        cells: {\n            values: [...values.slice(0, 3), Array(values[0].length).fill(''), ...values.slice(3)], // Add empty column\n            align: ['left', 'right', 'right', 'right', 'right', 'right'],\n            line: { width: 1, color: \"#DBDDDE\" },\n            font: { family: \"Inter, sans-serif\", size: 14, color: [\"black\"] },\n            fill: {\n                color: [\n                    forecast_colors, \n                    ...skill_colors.slice(0, 2), \n                    Array(forecasts.length).fill('grey'), // Divider column\n                    ...skill_colors.slice(2)\n                ]\n            },\n            height: 35\n        },\n        columnwidth: [1.4, 0.5, 0.5, 0.05, 0.5, 0.5, 0.5] // Make divider column very thin\n    }],\n    layout: {\n        title: {\n            text: \"Weekly temperature results\" + units,\n            xanchor: 'left',\n            x: 0\n        }\n    }\n}\n// return {\n    // data: [{\n    //     type: 'table',\n    //     header: {\n    //         values: header,\n    //         align: ['left', 'right', 'right', 'right', 'right'],\n    //         line: { width: 0, color: '#DBDDDE' },\n    //         font: { family: \"Inter, sans-serif\", size: 14, weight: \"bold\" },\n    //         fill: {\n    //             color: ['rgba(0,0,0,0)']\n    //         }\n    //     },\n    //     cells: {\n    //         values: values,\n    //         align: ['left', 'right', 'right', 'right', 'right'],\n    //         line: { color: \"#DBDDDE\", width: 1 },\n    //         font: { family: \"Inter, sans-serif\", size: 14, color: [\"black\"] },\n    //         fill: {\n    //             color: [forecast_colors, ...skill_colors]\n    //         },\n    //         height: 35\n\n    //     },\n    //     columnwidth: [1.2, 0.5, 0.5, 0.5, 0.5, 0.5]\n    // }]\n// }\n",
        "syncTimeRange": false,
        "timeCol": ""
      },
      "pluginVersion": "1.8.2",
      "targets": [
        {
          "datasource": {
            "type": "grafana-postgresql-datasource",
            "uid": "bdz3m3xs99p1cf"
          },
          "editorMode": "code",
          "format": "table",
          "rawQuery": true,
          "rawSql": "select * from \"$tmp2m_tab_name\"\n ${time_filter_query}",
          "refId": "A",
          "sql": {
            "columns": [
              {
                "parameters": [],
                "type": "function"
              }
            ],
            "groupBy": [
              {
                "property": {
                  "type": "string"
                },
                "type": "groupBy"
              }
            ],
            "limit": 50
          }
        },
        {
          "datasource": {
            "type": "grafana-postgresql-datasource",
            "uid": "bdz3m3xs99p1cf"
          },
          "editorMode": "code",
          "format": "table",
          "hide": false,
          "rawQuery": true,
          "rawSql": "select '${baseline}'",
          "refId": "B",
          "sql": {
            "columns": [
              {
                "parameters": [],
                "type": "function"
              }
            ],
            "groupBy": [
              {
                "property": {
                  "type": "string"
                },
                "type": "groupBy"
              }
            ],
            "limit": 50
          }
        }
      ],
      "title": "",
      "transparent": true,
      "type": "nline-plotlyjs-panel"
    },
    {
      "datasource": {
        "default": true,
        "type": "grafana-postgresql-datasource",
        "uid": "bdz3m3xs99p1cf"
      },
      "fieldConfig": {
        "defaults": {},
        "overrides": [
          {
            "matcher": {
              "id": "byName",
              "options": "forecast"
            },
            "properties": []
          },
          {
            "matcher": {
              "id": "byName",
              "options": "forecast"
            },
            "properties": []
          }
        ]
      },
      "gridPos": {
        "h": 12,
        "w": 12,
        "x": 12,
        "y": 6
      },
      "id": 2,
      "options": {
        "allData": {},
        "config": {},
        "data": [],
        "imgFormat": "png",
        "layout": {
          "font": {
            "family": "Inter, sans-serif"
          },
          "margin": {
            "b": 0,
            "l": 0,
            "r": 0,
            "t": 0
          },
          "paper_bgcolor": "#F4F5F5",
          "plog_bgcolor": "#F4F5F5",
          "title": {
            "align": "left",
            "automargin": true,
            "font": {
              "color": "black",
              "family": "Inter, sans-serif",
              "size": 14,
              "weight": 500
            },
            "pad": {
              "b": 30
            },
            "test": "blah",
            "text": "Weekly",
            "x": 0,
            "xanchor": "left"
          },
          "xaxis": {
            "automargin": true,
            "autorange": true,
            "type": "date"
          },
          "yaxis": {
            "automargin": true,
            "autorange": true
          }
        },
        "onclick": "",
        "resScale": 0,
        "script": "// Utility function to convert hex color to an RGB object\nfunction hexToRgb(hex) {\n    const bigint = parseInt(hex.slice(1), 16);\n    return {\n        r: (bigint >> 16) & 255,\n        g: (bigint >> 8) & 255,\n        b: bigint & 255\n    };\n}\n\n// Function to get interpolated color by passing a value from 0 to 1\nfunction getColor(value, cmin, cmax, colorMap) {\n    let colors;\n\n    // Define color scales based on the selected colormap\n    if (colorMap === 'BrBG') {\n        colors = [\n            \"#543005\",\n            \"#8C510A\", \"#BF812D\", \"#DFC27D\", \"#F6E8C3\",\n            \"#F5F5F5\", \"#C7EAE5\", \"#80CDC1\", \"#35978F\", \"#01665E\",\n            \"#003C30\"\n        ];\n    } else if (colorMap === 'balance') {\n        colors = [\n            \"#2a0a0a\",\n            \"#751b1b\", \"#b73c3c\", \"#e88484\", \"#f3c3c3\", // Negative side\n            \"#ffffff\",                                            // Neutral middle\n            \"#c3e4f3\", \"#84c2e8\", \"#3c9fb7\", \"#1b5e75\",  // Positive side\n            \"#0a2a2a\"\n        ];\n        colors = colors.reverse()\n    } else if (colorMap === 'RdBu') {\n        colors = ['#ff0000', '#ffffff', '#0000ff'];\n    } else if (colorMap === 'BuRd') {\n        colors = ['#0000ff', '#ffffff', '#ff0000'];    \n    } else {\n        throw new Error(\"Invalid colorMap. Choose 'BrBG', 'balance', 'BuRd', or 'RdBu'.\");\n    }\n\n    let x;\n    if (value > 0) {\n        x = 0.5 + (value / cmax) * 0.5;  // Map positive values from 0.5 to 1.0\n    } else if (value < 0) {\n        x = 0.5 + (value / (-cmin)) * 0.5;  // Map negative values from 0.0 to 0.5\n    } else {\n        x = 0.5;  // Zero maps to middle\n    }    \n\n    // Clamp value between 0 and 1\n    x = Math.min(1, Math.max(0, x));\n    if (isNaN(x)) {\n        return `rgba(255, 255, 255, 0.5)`;\n    }\n\n    // Compute exact position in color array\n    const scaledValue = x * (colors.length - 1);\n    const lowerIndex = Math.floor(scaledValue);\n    const upperIndex = Math.ceil(scaledValue);\n\n    // Edge case: if at the end of the array, return the last color\n    if (lowerIndex === upperIndex) {\n        const color = hexToRgb(colors[lowerIndex]);\n        return `rgba(${color.r}, ${color.g}, ${color.b}, 0.5)`;\n    }\n\n    // Interpolate between the two colors\n    const lowerColor = hexToRgb(colors[lowerIndex]);\n    const upperColor = hexToRgb(colors[upperIndex]);\n    const t = scaledValue - lowerIndex;\n\n    // Interpolate RGB channels\n    const r = Math.round(lowerColor.r + t * (upperColor.r - lowerColor.r));\n    const g = Math.round(lowerColor.g + t * (upperColor.g - lowerColor.g));\n    const b = Math.round(lowerColor.b + t * (upperColor.b - lowerColor.b));\n\n    // Return the interpolated color as an rgb(r, g, b) string\n    return `rgba(${r}, ${g}, ${b}, 0.5)`;\n}\n\nlet series = data.series[0]\nif (series.length == 0) {\n    return {\n        data: []\n    }\n}\nlet maximize;\nlet metric = variables['metric'].current.value;\nif (metric.startsWith('heidke') || metric.startsWith('pod') || metric.startsWith('ets')) {\n    maximize = true; // these metrics are maximized\n} else {\n    maximize = false;\n}\n\nif (variables.time_grouping.current.value != 'None') {\n    idx = 1\n} else {\n    idx = 0\n}\nforecasts = series.fields[1 + idx].values\nvalues = []\nskills = []\nheader = [\"Forecast\"]\norig_header = [\"forecast\"]\nlet max = -Infinity;\nlet min = Infinity;\nskill_baseline_idx = null;\nfor (var i = 0; i < forecasts.length; i = i + 1) {\n    if (variables.baseline.current.value == forecasts[i]) {\n        skill_baseline_idx = i\n    }\n}\n\nbaseline_values = []\nfor (var i = 2 + idx; i < series.fields.length; i = i + 1) {\n    baseline_values.push(series.fields[i].values[skill_baseline_idx])\n}\n\nlet skill_val;\nfor (var i = 2 + idx; i < series.fields.length; i = i + 1) {\n    v = series.fields[i].values\n    skill_values = []\n    for (var j = 0; j < v.length; j++) {\n        let val = parseFloat(v[j]);\n        if (val > max) {\n            max = val;\n        }\n        if (val < min) {\n            min = val;\n        }\n\n        if (maximize){\n            // Compute the skill of the distance from 1\n            skill_val = (1 - ((1-val) / (1-baseline_values[(i - 2 - idx)])));\n            skill_values.push(skill_val)\n\n        } else {\n            skill_val = (1 - (val / baseline_values[(i - 2 - idx)]));\n            skill_values.push(skill_val)\n        }\n    }\n    values.push(v)\n    skills.push(skill_values)\n    header.push(\"Week \" + (i - 1 - idx))\n    orig_header.push(\"week\" + (i - 1 - idx))\n}\n\nconsole.log(skills)\n\n// round to two decimal places\nvalues = values.map((week) => week.map((x) => { if (x) { return x.toFixed(2) } else { return '-' } }))\nforecasts = forecasts.map((forecast) => forecast.replaceAll('_', ' ').split(' ').map((word) => word[0].toUpperCase() + word.substring(1)).join(' '))\nvalues.unshift(forecasts)\n\n// Define a dictionary for custom renaming\nconst renameDict = {\n    \"Ecmwf Ifs Er\": \"ECMWF IFS ER\",\n    \"Ecmwf Ifs Er Debiased\": \"ECMWF IFS ER Debiased\",\n    \"Salient\": \"Salient\",\n    \"Fuxi\": \"FuXi S2S\",\n    \"Climatology 2015\": \"Climatology 1985-2014\",\n    \"Climatology Trend 2015\": \"Climatology 1985-2014 w/Trend\"\n};\n// Apply custom renaming to the first column of cellValues\nvalues[0] = values[0].map(value => renameDict[value] || value);\n\n// assign the forecast colors\nforecast_colors = []\nfor (var i = 0; i < forecasts.length; i++) {\n    forecast_colors.push('rgba(0,0,0,0)')\n}\n\nlet skill_colors = []\n// assign the skill colors\nlet colorMap, cmax, cmin;\n// if (variables['metric'].current.value == 'bias') {\n//     colormap = 'balance';\n//     cmax = max;\n//     cmin = min;\n// }\n// else {\n//     colormap = 'rdbu';\n//     cmax = 1;\n//     cmin = -1;\n// }\n// Determine color map and ranges based on metric\nswitch (variables['metric'].current.value) {\n    case 'bias':\n        colorMap = 'BrBG';\n        [cmin, cmax] = [min, max];\n        break;\n    case 'acc':\n        colorMap = 'RdBu';\n        [cmin, cmax] = [-1, 1];\n        break;\n    // Error metrics - smaller is better\n    case 'mae':\n    case 'crps':\n    case 'rmse':\n    case 'smape':\n    case 'seeps':\n        colorMap = 'RdBu';\n        [cmin, cmax] = [-1, 1];\n        break;\n    // Skill score metrics - larger is better\n    case 'heidke-1-5-10-20':\n    case 'pod-1':\n    case 'pod-5':\n    case 'pod-10':\n    case 'ets-1':\n    case 'ets-5':\n    case 'ets-10':\n        colorMap = 'RdBu';\n        [cmin, cmax] = [-1, 1];\n        break;\n    // FAR metrics - smaller is better\n    case 'far-1':\n    case 'far-5':\n    case 'far-10':\n        colorMap = 'RdBu';\n        [cmin, cmax] = [-1, 1]\n        break;\n    default:\n        colorMap = 'RdBu';\n        [cmin, cmax] = [-1, 1];\n}\n\nfor (var i = 0; i < skills.length; i++) {\n    let week_colors = [];\n    for (var j = 0; j < skills[i].length; j++) {\n        if (variables['metric'].current.value == 'acc' || variables['metric'].current.value == 'bias') {\n            val = parseFloat(values[i + 1][j]);\n        } else {\n            val = parseFloat(skills[i][j]);\n        }\n        week_colors.push(getColor(val, cmin, cmax, colorMap))\n    }\n    skill_colors.push(week_colors)\n}\n\n// Turn the metrics into links\norig_forecasts = series.fields[1 + idx].values\nmetric = variables.metric.current.value\ngrid = variables.grid.current.value\nregion = variables.region.current.value\ntime_grouping = variables.time_grouping.current.value\ntime_filter = variables.time_filter.current.value\nfor (var i = 1; i < values.length; i++) {\n    for (var j = 0; j < values[i].length; j++) {\n        url = `/d/ae39q2k3jv668d/plotly-maps?orgId=1&var-forecast=${orig_forecasts[j]}&var-metric=${metric}&var-lead=${orig_header[i]}&var-truth=era5&var-grid=${grid}&var-region=${region}&var-time_grouping=${time_grouping}&var-time_filter=${time_filter}`\n        values[i][j] = `<a href=\"${url}\">` + values[i][j] + '</a>'\n    }\n}\n\nvar units = \"\"\nif (metric == 'mae' || metric == 'bias' || metric == 'crps' || metric == 'rmse') {\n    units = \" (mm/day)\"\n}\nreturn {\n    data: [{\n        type: 'table',\n        header: {\n            values: [...header.slice(0, 3), '', ...header.slice(3)], // Add empty column for divider\n            align: ['left', 'right', 'right', 'right', 'right', 'right'],\n            line: { width: 0, color: '#DBDDDE' },\n            font: { family: \"Inter, sans-serif\", size: 14, weight: \"bold\" },\n            fill: {\n                color: ['rgba(0,0,0,0)']\n            }\n        },\n        cells: {\n            values: [...values.slice(0, 3), Array(values[0].length).fill(''), ...values.slice(3)], // Add empty column\n            align: ['left', 'right', 'right', 'right', 'right', 'right'],\n            line: { width: 1, color: \"#DBDDDE\" },\n            font: { family: \"Inter, sans-serif\", size: 14, color: [\"black\"] },\n            fill: {\n                color: [\n                    forecast_colors, \n                    ...skill_colors.slice(0, 2), \n                    Array(forecasts.length).fill('grey'), // Divider column\n                    ...skill_colors.slice(2)\n                ]\n            },\n            height: 35\n        },\n        columnwidth: [1.5, 0.51, 0.51, 0.05, 0.51, 0.51, 0.51] // Make divider column very thin\n    }],\n    layout: {\n        title: {\n            text: \"Weekly precipitation results\" + units,\n            xanchor: 'left',\n            x: 0\n        }\n    }\n}\n// return {\n//     data: [{\n//         type: 'table',\n//         header: {\n//             values: header,\n//             align: ['left', 'right', 'right', 'right', 'right'],\n//             line: { width: 0, color: '#DBDDDE' },\n//             font: { family: \"Inter, sans-serif\", size: 14, weight: \"bold\" },\n//             fill: {\n//                 color: ['rgba(0,0,0,0)']\n//             }\n//         },\n//         cells: {\n//             values: values,\n//             align: ['left', 'right', 'right', 'right', 'right'],\n//             line: { color: \"#DBDDDE\", width: 1 },\n//             font: { family: \"Inter, sans-serif\", size: 14, color: [\"black\"] },\n//             fill: {\n//                 color: [forecast_colors, ...skill_colors]\n//             },\n//             height: 35\n\n//         },\n//         columnwidth: [1.2, 0.5, 0.5, 0.5, 0.5, 0.5]\n//     }]\n// }\n",
        "syncTimeRange": false,
        "timeCol": ""
      },
      "pluginVersion": "1.8.2",
      "targets": [
        {
          "datasource": {
            "type": "grafana-postgresql-datasource",
            "uid": "bdz3m3xs99p1cf"
          },
          "editorMode": "code",
          "format": "table",
          "rawQuery": true,
          "rawSql": "select * from \"$precip_tab_name\"\n ${time_filter_query}",
          "refId": "A",
          "sql": {
            "columns": [
              {
                "parameters": [],
                "type": "function"
              }
            ],
            "groupBy": [
              {
                "property": {
                  "type": "string"
                },
                "type": "groupBy"
              }
            ],
            "limit": 50
          }
        },
        {
          "datasource": {
            "type": "grafana-postgresql-datasource",
            "uid": "bdz3m3xs99p1cf"
          },
          "editorMode": "code",
          "format": "table",
          "hide": false,
          "rawQuery": true,
          "rawSql": "select '${baseline}'",
          "refId": "B",
          "sql": {
            "columns": [
              {
                "parameters": [],
                "type": "function"
              }
            ],
            "groupBy": [
              {
                "property": {
                  "type": "string"
                },
                "type": "groupBy"
              }
            ],
            "limit": 50
          }
        }
      ],
      "title": "",
      "transparent": true,
      "type": "nline-plotlyjs-panel"
    },
    {
      "datasource": {
        "default": true,
        "type": "grafana-postgresql-datasource",
        "uid": "bdz3m3xs99p1cf"
      },
      "fieldConfig": {
        "defaults": {},
        "overrides": [
          {
            "matcher": {
              "id": "byName",
              "options": "forecast"
            },
            "properties": []
          },
          {
            "matcher": {
              "id": "byName",
              "options": "forecast"
            },
            "properties": []
          }
        ]
      },
      "gridPos": {
        "h": 5,
        "w": 12,
        "x": 0,
        "y": 18
      },
      "id": 4,
      "options": {
        "allData": {},
        "config": {},
        "data": [],
        "imgFormat": "png",
        "layout": {
          "font": {
            "family": "Inter, sans-serif"
          },
          "margin": {
            "b": 0,
            "l": 0,
            "r": 0,
            "t": 0
          },
          "paper_bgcolor": "#F4F5F5",
          "plog_bgcolor": "#F4F5F5",
          "title": {
            "align": "left",
            "automargin": true,
            "font": {
              "color": "black",
              "family": "Inter, sans-serif",
              "size": 14,
              "weight": 500
            },
            "pad": {
              "b": 30
            },
            "x": 0,
            "xanchor": "left"
          },
          "xaxis": {
            "automargin": true,
            "autorange": true,
            "type": "date"
          },
          "yaxis": {
            "automargin": true,
            "autorange": true
          }
        },
        "onclick": "",
        "resScale": 0,
        "script": "// Utility function to convert hex color to an RGB object\nfunction hexToRgb(hex) {\n    const bigint = parseInt(hex.slice(1), 16);\n    return {\n        r: (bigint >> 16) & 255,\n        g: (bigint >> 8) & 255,\n        b: bigint & 255\n    };\n}\n\n// Function to get interpolated color by passing a value from 0 to 1\nfunction getColor(value, cmin, cmax, colorMap) {\n    let colors;\n\n    // Define color scales based on the selected colormap\n    if (colorMap === 'BrBG') {\n        colors = [\n            \"#543005\",\n            \"#8C510A\", \"#BF812D\", \"#DFC27D\", \"#F6E8C3\",\n            \"#F5F5F5\", \"#C7EAE5\", \"#80CDC1\", \"#35978F\", \"#01665E\",\n            \"#003C30\"\n        ];\n    } else if (colorMap === 'balance') {\n        colors = [\n            \"#2a0a0a\",\n            \"#751b1b\", \"#b73c3c\", \"#e88484\", \"#f3c3c3\", // Negative side\n            \"#ffffff\",                                            // Neutral middle\n            \"#c3e4f3\", \"#84c2e8\", \"#3c9fb7\", \"#1b5e75\",  // Positive side\n            \"#0a2a2a\"\n        ];\n        colors = colors.reverse()\n    } else if (colorMap === 'RdBu') {\n        colors = ['#ff0000', '#ffffff', '#0000ff'];\n    } else if (colorMap === 'BuRd') {\n        colors = ['#0000ff', '#ffffff', '#ff0000'];    \n    } else {\n        throw new Error(\"Invalid colorMap. Choose 'BrBG', 'balance', 'BuRd', or 'RdBu'.\");\n    }\n\n    let x;\n    if (value > 0) {\n        x = 0.5 + (value / cmax) * 0.5;  // Map positive values from 0.5 to 1.0\n    } else if (value < 0) {\n        x = 0.5 + (value / (-cmin)) * 0.5;  // Map negative values from 0.0 to 0.5\n    } else {\n        x = 0.5;  // Zero maps to middle\n    }    \n\n    // Clamp value between 0 and 1\n    x = Math.min(1, Math.max(0, x));\n    if (isNaN(x)) {\n        return `rgba(255, 255, 255, 0.5)`;\n    }\n\n    // Compute exact position in color array\n    const scaledValue = x * (colors.length - 1);\n    const lowerIndex = Math.floor(scaledValue);\n    const upperIndex = Math.ceil(scaledValue);\n\n    // Edge case: if at the end of the array, return the last color\n    if (lowerIndex === upperIndex) {\n        const color = hexToRgb(colors[lowerIndex]);\n        return `rgba(${color.r}, ${color.g}, ${color.b}, 0.5)`;\n    }\n\n    // Interpolate between the two colors\n    const lowerColor = hexToRgb(colors[lowerIndex]);\n    const upperColor = hexToRgb(colors[upperIndex]);\n    const t = scaledValue - lowerIndex;\n\n    // Interpolate RGB channels\n    const r = Math.round(lowerColor.r + t * (upperColor.r - lowerColor.r));\n    const g = Math.round(lowerColor.g + t * (upperColor.g - lowerColor.g));\n    const b = Math.round(lowerColor.b + t * (upperColor.b - lowerColor.b));\n\n    // Return the interpolated color as an rgb(r, g, b) string\n    return `rgba(${r}, ${g}, ${b}, 0.5)`;\n}\n\nlet series = data.series[0]\nif (series.length == 0) {\n    return {\n        data: []\n    }\n}\nlet maximize;\nlet metric = variables['metric'].current.value;\nif (metric.startsWith('heidke') || metric.startsWith('pod') || metric.startsWith('ets')) {\n    maximize = true; // these metrics are maximized\n} else {\n    maximize = false;\n}\n\nif (variables.time_grouping.current.value != 'None') {\n    idx = 1\n} else {\n    idx = 0\n}\nforecasts = series.fields[1 + idx].values\nvalues = []\nskills = []\nheader = [\"Forecast\"]\norig_header = [\"forecast\"]\nlet max = -Infinity;\nlet min = Infinity;\nskill_baseline_idx = null;\nfor (var i = 0; i < forecasts.length; i = i + 1) {\n    if (variables.baseline.current.value == forecasts[i]) {\n        skill_baseline_idx = i\n    }\n}\n\nbaseline_values = []\nfor (var i = 2 + idx; i < series.fields.length; i = i + 1) {\n    baseline_values.push(series.fields[i].values[skill_baseline_idx])\n}\n\nlet skill_val;\nfor (var i = 2 + idx; i < series.fields.length; i = i + 1) {\n    v = series.fields[i].values\n    skill_values = []\n    for (var j = 0; j < v.length; j++) {\n        let val = parseFloat(v[j]);\n        if (val > max) {\n            max = val;\n        }\n        if (val < min) {\n            min = val;\n        }\n\n        if (maximize){\n            // Compute the skill of the distance from 1\n            skill_val = (1 - ((1-val) / (1-baseline_values[(i - 2 - idx)])));\n\n        } else {\n            skill_val = (1 - (val / baseline_values[(i - 2 - idx)]));\n        }\n        skill_values.push(skill_val)\n    }\n    values.push(v)\n    skills.push(skill_values)\n    header.push(\"Month \" + (i - 1 - idx))\n    orig_header.push(\"month\" + (i - 1 - idx))\n}\n\nconsole.log(skills)\n\n// round to two decimal places\nvalues = values.map((week) => week.map((x) => { if (x) { return x.toFixed(2) } else { return '-' } }))\nforecasts = forecasts.map((forecast) => forecast.replaceAll('_', ' ').split(' ').map((word) => word[0].toUpperCase() + word.substring(1)).join(' '))\nvalues.unshift(forecasts)\n\n// Define a dictionary for custom renaming\nconst renameDict = {\n    \"Ecmwf Ifs Er\": \"ECMWF IFS ER\",\n    \"Ecmwf Ifs Er Debiased\": \"ECMWF IFS ER Debiased\",\n    \"Salient\": \"Salient\",\n    \"Fuxi\": \"FuXi S2S\",\n    \"Climatology 2015\": \"Climatology 1985-2014\",\n    \"Climatology Trend 2015\": \"Climatology 1985-2014 w/Trend\"\n};\n\n// Apply custom renaming to the first column of cellValues\nvalues[0] = values[0].map(value => renameDict[value] || value);\n\n// assign the forecast colors\nforecast_colors = []\nfor (var i = 0; i < forecasts.length; i++) {\n    forecast_colors.push('rgba(0,0,0,0)')\n}\n\nlet skill_colors = []\n// assign the skill colors\nlet colorMap, cmax, cmin;\n// if (variables['metric'].current.value == 'bias') {\n//     colormap = 'balance';\n//     cmax = max;\n//     cmin = min;\n// }\n// else {\n//     colormap = 'rdbu';\n//     cmax = 1;\n//     cmin = -1;\n// }\n// Determine color map and ranges based on metric\nswitch (variables['metric'].current.value) {\n    case 'bias':\n        colorMap = 'BuRd';\n        [cmin, cmax] = [min, max];\n        break;\n    case 'acc':\n        colorMap = 'RdBu';\n        [cmin, cmax] = [-1, 1];\n        break;\n    // Error metrics - smaller is better\n    case 'mae':\n    case 'crps':\n    case 'rmse':\n    case 'smape':\n    case 'seeps':\n        colorMap = 'RdBu';\n        [cmin, cmax] = [-1, 1];\n        break;\n    // Skill score metrics - larger is better\n    case 'heidke-1-5-10-20':\n    case 'pod-1':\n    case 'pod-5':\n    case 'pod-10':\n    case 'ets-1':\n    case 'ets-5':\n    case 'ets-10':\n        colorMap = 'RdBu';\n        [cmin, cmax] = [-1, 1];\n        break;\n    // FAR metrics - smaller is better\n    case 'far-1':\n    case 'far-5':\n    case 'far-10':\n        colorMap = 'RdBu';\n        [cmin, cmax] = [-1, 1]\n        break;\n    default:\n        colorMap = 'RdBu';\n        [cmin, cmax] = [-1, 1];\n}\n\nfor (var i = 0; i < skills.length; i++) {\n    let week_colors = [];\n    for (var j = 0; j < skills[i].length; j++) {\n        if (variables['metric'].current.value == 'acc' || variables['metric'].current.value == 'bias') {\n            val = parseFloat(values[i + 1][j]);\n        } else {\n            val = parseFloat(skills[i][j]);\n        }\n        week_colors.push(getColor(val, cmin, cmax, colorMap))\n    }\n    skill_colors.push(week_colors)\n}\n\n// Turn the metrics into links\n// orig_forecasts = series.fields[1 + idx].values\n// metric = variables.metric.current.value\n// grid = variables.grid.current.value\n// region = variables.region.current.value\n// time_grouping = variables.time_grouping.current.value\n// time_filter = variables.time_filter.current.value\n// for (var i = 1; i < values.length; i++) {\n//     for (var j = 0; j < values[i].length; j++) {\n//         url = `/d/ae39q2k3jv668d/plotly-maps?orgId=1&var-forecast=${orig_forecasts[j]}&var-metric=${metric}&var-lead=${orig_header[i]}&var-truth=era5&var-grid=${grid}&var-region=${region}&var-time_grouping=${time_grouping}&var-time_filter=${time_filter}`\n//         values[i][j] = `<a href=\"${url}\">` + values[i][j] + '</a>'\n//     }\n// }\n\nvar units = \"\"\nif (metric == 'mae' || metric == 'bias' || metric == 'crps' || metric == 'rmse') {\n    units = \" (C)\"\n}\n\nreturn {\n    data: [{\n        type: 'table',\n        header: {\n            values: [...header.slice(0, 2), '', ...header.slice(2)], // Add empty column for divider\n            align: ['left', 'right', 'right', 'right', 'right', 'right'],\n            line: { width: 0, color: '#DBDDDE' },\n            font: { family: \"Inter, sans-serif\", size: 14, weight: \"bold\" },\n            fill: {\n                color: ['rgba(0,0,0,0)']\n            }\n        },\n        cells: {\n            values: [...values.slice(0, 2), Array(values[0].length).fill(''), ...values.slice(2)], // Add empty column\n            align: ['left', 'right', 'right', 'right', 'right', 'right'],\n            line: { width: 1, color: \"#DBDDDE\" },\n            font: { family: \"Inter, sans-serif\", size: 14, color: [\"black\"] },\n            fill: {\n                color: [\n                    forecast_colors, \n                    ...skill_colors.slice(0, 1), \n                    Array(forecasts.length).fill('grey'), // Divider column\n                    ...skill_colors.slice(1)\n                ]\n            },\n            height: 35\n        },\n        columnwidth: [1.2, 0.5, 0.03, 0.5, 0.5, 0.5] // Make divider column very thin\n    }],\n    layout: {\n        title: {\n            text: \"Monthy temperature results\" + units,\n            xanchor: 'left',\n            x: 0\n        }\n    }\n}\n// return {\n//     data: [{\n//         type: 'table',\n//         header: {\n//             values: header,\n//             align: ['left', 'right', 'right', 'right', 'right'],\n//             line: { width: 0, color: '#DBDDDE' },\n//             font: { family: \"Inter, sans-serif\", size: 14, weight: \"bold\" },\n//             fill: {\n//                 color: ['rgba(0,0,0,0)']\n//             }\n//         },\n//         cells: {\n//             values: values,\n//             align: ['left', 'right', 'right', 'right', 'right'],\n//             line: { color: \"#DBDDDE\", width: 1 },\n//             font: { family: \"Inter, sans-serif\", size: 14, color: [\"black\"] },\n//             fill: {\n//                 color: [forecast_colors, ...skill_colors]\n//             },\n//             height: 35\n\n//         },\n//         columnwidth: [1.2, 0.5, 0.5, 0.5, 0.5, 0.5]\n//     }]\n// }\n",
        "syncTimeRange": false,
        "timeCol": ""
      },
      "pluginVersion": "1.8.2",
      "targets": [
        {
          "datasource": {
            "type": "grafana-postgresql-datasource",
            "uid": "bdz3m3xs99p1cf"
          },
          "editorMode": "code",
          "format": "table",
          "rawQuery": true,
          "rawSql": "select * from \"$seasonal_tmp2m_tab_name\"\n ${time_filter_query}",
          "refId": "A",
          "sql": {
            "columns": [
              {
                "parameters": [],
                "type": "function"
              }
            ],
            "groupBy": [
              {
                "property": {
                  "type": "string"
                },
                "type": "groupBy"
              }
            ],
            "limit": 50
          }
        },
        {
          "datasource": {
            "type": "grafana-postgresql-datasource",
            "uid": "bdz3m3xs99p1cf"
          },
          "editorMode": "code",
          "format": "table",
          "hide": false,
          "rawQuery": true,
          "rawSql": "select '${baseline}'",
          "refId": "B",
          "sql": {
            "columns": [
              {
                "parameters": [],
                "type": "function"
              }
            ],
            "groupBy": [
              {
                "property": {
                  "type": "string"
                },
                "type": "groupBy"
              }
            ],
            "limit": 50
          }
        }
      ],
      "title": "",
      "transparent": true,
      "type": "nline-plotlyjs-panel"
    },
    {
      "datasource": {
        "default": true,
        "type": "grafana-postgresql-datasource",
        "uid": "bdz3m3xs99p1cf"
      },
      "fieldConfig": {
        "defaults": {},
        "overrides": [
          {
            "matcher": {
              "id": "byName",
              "options": "forecast"
            },
            "properties": []
          },
          {
            "matcher": {
              "id": "byName",
              "options": "forecast"
            },
            "properties": []
          }
        ]
      },
      "gridPos": {
        "h": 5,
        "w": 12,
        "x": 12,
        "y": 18
      },
      "id": 3,
      "options": {
        "allData": {},
        "config": {},
        "data": [],
        "imgFormat": "png",
        "layout": {
          "font": {
            "family": "Inter, sans-serif"
          },
          "margin": {
            "b": 0,
            "l": 0,
            "r": 0,
            "t": 0
          },
          "paper_bgcolor": "#F4F5F5",
          "plog_bgcolor": "#F4F5F5",
          "title": {
            "align": "left",
            "automargin": true,
            "font": {
              "color": "black",
              "family": "Inter, sans-serif",
              "size": 14,
              "weight": 500
            },
            "pad": {
              "b": 30
            },
            "x": 0,
            "xanchor": "left"
          },
          "xaxis": {
            "automargin": true,
            "autorange": true,
            "type": "date"
          },
          "yaxis": {
            "automargin": true,
            "autorange": true
          }
        },
        "onclick": "",
        "resScale": 0,
        "script": "// Utility function to convert hex color to an RGB object\nfunction hexToRgb(hex) {\n    const bigint = parseInt(hex.slice(1), 16);\n    return {\n        r: (bigint >> 16) & 255,\n        g: (bigint >> 8) & 255,\n        b: bigint & 255\n    };\n}\n\n// Function to get interpolated color by passing a value from 0 to 1\nfunction getColor(value, cmin, cmax, colorMap) {\n    let colors;\n\n    // Define color scales based on the selected colormap\n    if (colorMap === 'BrBG') {\n        colors = [\n            \"#543005\",\n            \"#8C510A\", \"#BF812D\", \"#DFC27D\", \"#F6E8C3\",\n            \"#F5F5F5\", \"#C7EAE5\", \"#80CDC1\", \"#35978F\", \"#01665E\",\n            \"#003C30\"\n        ];\n    } else if (colorMap === 'balance') {\n        colors = [\n            \"#2a0a0a\",\n            \"#751b1b\", \"#b73c3c\", \"#e88484\", \"#f3c3c3\", // Negative side\n            \"#ffffff\",                                            // Neutral middle\n            \"#c3e4f3\", \"#84c2e8\", \"#3c9fb7\", \"#1b5e75\",  // Positive side\n            \"#0a2a2a\"\n        ];\n        colors = colors.reverse()\n    } else if (colorMap === 'RdBu') {\n        colors = ['#ff0000', '#ffffff', '#0000ff'];\n    } else if (colorMap === 'BuRd') {\n        colors = ['#0000ff', '#ffffff', '#ff0000'];    \n    } else {\n        throw new Error(\"Invalid colorMap. Choose 'BrBG', 'balance', 'BuRd', or 'RdBu'.\");\n    }\n\n    let x;\n    if (value > 0) {\n        x = 0.5 + (value / cmax) * 0.5;  // Map positive values from 0.5 to 1.0\n    } else if (value < 0) {\n        x = 0.5 + (value / (-cmin)) * 0.5;  // Map negative values from 0.0 to 0.5\n    } else {\n        x = 0.5;  // Zero maps to middle\n    }    \n\n    // Clamp value between 0 and 1\n    x = Math.min(1, Math.max(0, x));\n    if (isNaN(x)) {\n        return `rgba(255, 255, 255, 0.5)`;\n    }\n\n    // Compute exact position in color array\n    const scaledValue = x * (colors.length - 1);\n    const lowerIndex = Math.floor(scaledValue);\n    const upperIndex = Math.ceil(scaledValue);\n\n    // Edge case: if at the end of the array, return the last color\n    if (lowerIndex === upperIndex) {\n        const color = hexToRgb(colors[lowerIndex]);\n        return `rgba(${color.r}, ${color.g}, ${color.b}, 0.5)`;\n    }\n\n    // Interpolate between the two colors\n    const lowerColor = hexToRgb(colors[lowerIndex]);\n    const upperColor = hexToRgb(colors[upperIndex]);\n    const t = scaledValue - lowerIndex;\n\n    // Interpolate RGB channels\n    const r = Math.round(lowerColor.r + t * (upperColor.r - lowerColor.r));\n    const g = Math.round(lowerColor.g + t * (upperColor.g - lowerColor.g));\n    const b = Math.round(lowerColor.b + t * (upperColor.b - lowerColor.b));\n\n    // Return the interpolated color as an rgb(r, g, b) string\n    return `rgba(${r}, ${g}, ${b}, 0.5)`;\n}\n\nlet series = data.series[0]\nif (series.length == 0) {\n    return {\n        data: []\n    }\n}\nlet maximize;\nlet metric = variables['metric'].current.value;\nif (metric.startsWith('heidke') || metric.startsWith('pod') || metric.startsWith('ets')) {\n    maximize = true; // these metrics are maximized\n} else {\n    maximize = false;\n}\n\nif (variables.time_grouping.current.value != 'None') {\n    idx = 1\n} else {\n    idx = 0\n}\nforecasts = series.fields[1 + idx].values\nvalues = []\nskills = []\nheader = [\"Forecast\"]\norig_header = [\"forecast\"]\nlet max = -Infinity;\nlet min = Infinity;\nskill_baseline_idx = null;\nfor (var i = 0; i < forecasts.length; i = i + 1) {\n    if (variables.baseline.current.value == forecasts[i]) {\n        skill_baseline_idx = i\n    }\n}\n\nbaseline_values = []\nfor (var i = 2 + idx; i < series.fields.length; i = i + 1) {\n    baseline_values.push(series.fields[i].values[skill_baseline_idx])\n}\n\nlet skill_val;\nfor (var i = 2 + idx; i < series.fields.length; i = i + 1) {\n    v = series.fields[i].values\n    skill_values = []\n    for (var j = 0; j < v.length; j++) {\n        let val = parseFloat(v[j]);\n        if (val > max) {\n            max = val;\n        }\n        if (val < min) {\n            min = val;\n        }\n\n        if (maximize){\n            // Compute the skill of the distance from 1\n            skill_val = (1 - ((1-val) / (1-baseline_values[(i - 2 - idx)])));\n\n        } else {\n            skill_val = (1 - (val / baseline_values[(i - 2 - idx)]));\n        }\n        skill_values.push(skill_val)\n    }\n    values.push(v)\n    skills.push(skill_values)\n    header.push(\"Month \" + (i - 1 - idx))\n    orig_header.push(\"month\" + (i - 1 - idx))\n}\n\nconsole.log(skills)\n\n// round to two decimal places\nvalues = values.map((week) => week.map((x) => { if (x) { return x.toFixed(2) } else { return '-' } }))\nforecasts = forecasts.map((forecast) => forecast.replaceAll('_', ' ').split(' ').map((word) => word[0].toUpperCase() + word.substring(1)).join(' '))\nvalues.unshift(forecasts)\n\n// Define a dictionary for custom renaming\nconst renameDict = {\n    \"Ecmwf Ifs Er\": \"ECMWF IFS ER\",\n    \"Ecmwf Ifs Er Debiased\": \"ECMWF IFS ER Debiased\",\n    \"Salient\": \"Salient\",\n    \"Fuxi\": \"FuXi S2S\",\n    \"Climatology 2015\": \"Climatology 1985-2014\",\n    \"Climatology Trend 2015\": \"Climatology 1985-2014 w/Trend\"\n};\n\n// Apply custom renaming to the first column of cellValues\nvalues[0] = values[0].map(value => renameDict[value] || value);\n\n// assign the forecast colors\nforecast_colors = []\nfor (var i = 0; i < forecasts.length; i++) {\n    forecast_colors.push('rgba(0,0,0,0)')\n}\n\nlet skill_colors = []\n// assign the skill colors\nlet colorMap, cmax, cmin;\n// if (variables['metric'].current.value == 'bias') {\n//     colormap = 'balance';\n//     cmax = max;\n//     cmin = min;\n// }\n// else {\n//     colormap = 'rdbu';\n//     cmax = 1;\n//     cmin = -1;\n// }\n// Determine color map and ranges based on metric\nswitch (variables['metric'].current.value) {\n    case 'bias':\n        colorMap = 'BrBG';\n        [cmin, cmax] = [min, max];\n        break;\n    case 'acc':\n        colorMap = 'RdBu';\n        [cmin, cmax] = [-1, 1];\n        break;\n    // Error metrics - smaller is better\n    case 'mae':\n    case 'crps':\n    case 'rmse':\n    case 'smape':\n    case 'seeps':\n        colorMap = 'RdBu';\n        [cmin, cmax] = [-1, 1];\n        break;\n    // Skill score metrics - larger is better\n    case 'heidke-1-5-10-20':\n    case 'pod-1':\n    case 'pod-5':\n    case 'pod-10':\n    case 'ets-1':\n    case 'ets-5':\n    case 'ets-10':\n        colorMap = 'RdBu';\n        [cmin, cmax] = [-1, 1];\n        break;\n    // FAR metrics - smaller is better\n    case 'far-1':\n    case 'far-5':\n    case 'far-10':\n        colorMap = 'RdBu';\n        [cmin, cmax] = [-1, 1]\n        break;\n    default:\n        colorMap = 'RdBu';\n        [cmin, cmax] = [-1, 1];\n}\n\nfor (var i = 0; i < skills.length; i++) {\n    let week_colors = [];\n    for (var j = 0; j < skills[i].length; j++) {\n        if (variables['metric'].current.value == 'acc' || variables['metric'].current.value == 'bias') {\n            val = parseFloat(values[i + 1][j]);\n        } else {\n            val = parseFloat(skills[i][j]);\n        }\n        week_colors.push(getColor(val, cmin, cmax, colorMap))\n    }\n    skill_colors.push(week_colors)\n}\n\n// Turn the metrics into links\n// orig_forecasts = series.fields[1 + idx].values\n// metric = variables.metric.current.value\n// grid = variables.grid.current.value\n// region = variables.region.current.value\n// time_grouping = variables.time_grouping.current.value\n// time_filter = variables.time_filter.current.value\n// for (var i = 1; i < values.length; i++) {\n//     for (var j = 0; j < values[i].length; j++) {\n//         url = `/d/ae39q2k3jv668d/plotly-maps?orgId=1&var-forecast=${orig_forecasts[j]}&var-metric=${metric}&var-lead=${orig_header[i]}&var-truth=era5&var-grid=${grid}&var-region=${region}&var-time_grouping=${time_grouping}&var-time_filter=${time_filter}`\n//         values[i][j] = `<a href=\"${url}\">` + values[i][j] + '</a>'\n//     }\n// }\n\nvar units = \"\"\nif (metric == 'mae' || metric == 'bias' || metric == 'crps' || metric == 'rmse') {\n    units = \" (mm/day)\"\n}\n\nreturn {\n    data: [{\n        type: 'table',\n        header: {\n            values: [...header.slice(0, 2), '', ...header.slice(2)], // Add empty column for divider\n            align: ['left', 'right', 'right', 'right', 'right', 'right'],\n            line: { width: 0, color: '#DBDDDE' },\n            font: { family: \"Inter, sans-serif\", size: 14, weight: \"bold\" },\n            fill: {\n                color: ['rgba(0,0,0,0)']\n            }\n        },\n        cells: {\n            values: [...values.slice(0, 2), Array(values[0].length).fill(''), ...values.slice(2)], // Add empty column\n            align: ['left', 'right', 'right', 'right', 'right', 'right'],\n            line: { width: 1, color: \"#DBDDDE\" },\n            font: { family: \"Inter, sans-serif\", size: 14, color: [\"black\"] },\n            fill: {\n                color: [\n                    forecast_colors, \n                    ...skill_colors.slice(0, 1), \n                    Array(forecasts.length).fill('grey'), // Divider column\n                    ...skill_colors.slice(1)\n                ]\n            },\n            height: 35\n        },\n        columnwidth: [1.2, 0.5, 0.03, 0.5, 0.5, 0.5] // Make divider column very thin\n    }],\n    layout: {\n        title: {\n            text: \"Monthy precipitation results\" + units,\n            xanchor: 'left',\n            x: 0\n        }\n    }\n}",
        "syncTimeRange": false,
        "timeCol": ""
      },
      "pluginVersion": "1.8.2",
      "targets": [
        {
          "datasource": {
            "type": "grafana-postgresql-datasource",
            "uid": "bdz3m3xs99p1cf"
          },
          "editorMode": "code",
          "format": "table",
          "rawQuery": true,
          "rawSql": "select * from \"$seasonal_precip_tab_name\"\n ${time_filter_query}",
          "refId": "A",
          "sql": {
            "columns": [
              {
                "parameters": [],
                "type": "function"
              }
            ],
            "groupBy": [
              {
                "property": {
                  "type": "string"
                },
                "type": "groupBy"
              }
            ],
            "limit": 50
          }
        },
        {
          "datasource": {
            "type": "grafana-postgresql-datasource",
            "uid": "bdz3m3xs99p1cf"
          },
          "editorMode": "code",
          "format": "table",
          "hide": false,
          "rawQuery": true,
          "rawSql": "select '${baseline}'",
          "refId": "B",
          "sql": {
            "columns": [
              {
                "parameters": [],
                "type": "function"
              }
            ],
            "groupBy": [
              {
                "property": {
                  "type": "string"
                },
                "type": "groupBy"
              }
            ],
            "limit": 50
          }
        }
      ],
      "title": "",
      "transparent": true,
      "type": "nline-plotlyjs-panel"
    }
  ],
  "preload": false,
  "refresh": "",
  "schemaVersion": 40,
  "tags": [],
  "templating": {
    "list": [
      {
        "current": {
          "text": "mae",
          "value": "mae"
        },
        "includeAll": false,
        "label": "Metric",
        "name": "metric",
        "options": [
          {
            "selected": true,
            "text": "MAE",
            "value": "mae"
          },
          {
            "selected": false,
            "text": "CRPS",
            "value": "crps"
          },
          {
            "selected": false,
            "text": "RMSE",
            "value": "rmse"
          },
          {
            "selected": false,
            "text": "ACC",
            "value": "acc"
          },
          {
            "selected": false,
            "text": "Bias",
            "value": "bias"
          },
          {
            "selected": false,
            "text": "SMAPE",
            "value": "smape"
          },
          {
            "selected": false,
            "text": "SEEPS",
            "value": "seeps"
          },
          {
            "selected": false,
            "text": "Heidke (1/5/10/20mm)",
            "value": "heidke-1-5-10-20"
          },
          {
            "selected": false,
            "text": "POD 1mm",
            "value": "pod-1"
          },
          {
            "selected": false,
            "text": "POD 5mm",
            "value": "pod-5"
          },
          {
            "selected": false,
            "text": "POD 10mm",
            "value": "pod-10"
          },
          {
            "selected": false,
            "text": "FAR 1mm",
            "value": "far-1"
          },
          {
            "selected": false,
            "text": "FAR 5mm",
            "value": "far-5"
          },
          {
            "selected": false,
            "text": "FAR 10mm",
            "value": "far-10"
          },
          {
            "selected": false,
            "text": "ETS 1mm",
            "value": "ets-1"
          },
          {
            "selected": false,
            "text": "ETS 5mm",
            "value": "ets-5"
          },
          {
            "selected": false,
            "text": "ETS 10mm",
            "value": "ets-10"
          }
        ],
        "query": "MAE : mae, CRPS : crps, RMSE : rmse, ACC : acc, Bias : bias, SMAPE : smape, SEEPS : seeps, Heidke (1/5/10/20mm) : heidke-1-5-10-20, POD 1mm : pod-1, POD 5mm : pod-5, POD 10mm : pod-10, FAR 1mm : far-1, FAR 5mm : far-5, FAR 10mm : far-10, ETS 1mm : ets-1, ETS 5mm : ets-5, ETS 10mm : ets-10",
        "type": "custom"
      },
      {
        "current": {
          "text": "Clim 1985-2014",
          "value": "climatology_2015"
        },
        "datasource": {
          "type": "grafana-postgresql-datasource",
          "uid": "bdz3m3xs99p1cf"
        },
        "definition": "select \nforecast as __value,\ncase\n when forecast = 'salient' then 'Salient' \nwhen forecast = 'climatology_2015' then 'Clim 1985-2014' \nwhen forecast = 'climatology_trend_2015' then 'Clim + Trend' \nwhen forecast = 'climatology_rolling' then 'Clim Rolling' \nwhen forecast = 'ecmwf_ifs_er' then 'ECMWF IFS ER' \nwhen forecast = 'ecmwf_ifs_er_debiased' then 'ECMWF IFS ER Debiased' \nwhen forecast = 'fuxi' then 'FuXi S2S' \n else forecast\nend as __text\nfrom \"${precip_tab_name_baseline}\" where week1 is not null",
        "includeAll": false,
        "label": "Baseline",
        "name": "baseline",
        "options": [],
        "query": "select \nforecast as __value,\ncase\n when forecast = 'salient' then 'Salient' \nwhen forecast = 'climatology_2015' then 'Clim 1985-2014' \nwhen forecast = 'climatology_trend_2015' then 'Clim + Trend' \nwhen forecast = 'climatology_rolling' then 'Clim Rolling' \nwhen forecast = 'ecmwf_ifs_er' then 'ECMWF IFS ER' \nwhen forecast = 'ecmwf_ifs_er_debiased' then 'ECMWF IFS ER Debiased' \nwhen forecast = 'fuxi' then 'FuXi S2S' \n else forecast\nend as __text\nfrom \"${precip_tab_name_baseline}\" where week1 is not null",
        "refresh": 1,
        "regex": "",
        "type": "query"
      },
      {
        "current": {
          "text": "era5",
          "value": "era5"
        },
        "includeAll": false,
        "label": "Ground Truth",
        "name": "truth",
        "options": [
          {
            "selected": true,
            "text": "ERA5",
            "value": "era5"
          }
        ],
        "query": "ERA5 : era5",
        "type": "custom"
      },
      {
        "current": {
          "text": "global0_25",
          "value": "global0_25"
        },
        "includeAll": false,
        "label": "Grid",
        "name": "grid",
        "options": [
          {
            "selected": false,
            "text": "1.5",
            "value": "global1_5"
          },
          {
            "selected": true,
            "text": "0.25",
            "value": "global0_25"
          }
        ],
        "query": "1.5 : global1_5, 0.25 : global0_25",
        "type": "custom"
      },
      {
        "current": {
          "text": "east_africa",
          "value": "east_africa"
        },
        "includeAll": false,
        "label": "Region",
        "name": "region",
        "options": [
          {
            "selected": false,
            "text": "Africa",
            "value": "africa"
          },
          {
            "selected": true,
            "text": "East Africa",
            "value": "east_africa"
          },
          {
            "selected": false,
            "text": "Global",
            "value": "global"
          },
          {
            "selected": false,
            "text": "CONUS",
            "value": "conus"
          },
          {
            "selected": false,
            "text": "Nigeria",
            "value": "nigeria"
          },
          {
            "selected": false,
            "text": "Chile",
            "value": "chile"
          },
          {
            "selected": false,
            "text": "Kenya",
            "value": "kenya"
          }
        ],
        "query": "Africa : africa, East Africa : east_africa, Global : global, CONUS : conus, Nigeria : nigeria, Chile : chile, Kenya : kenya",
        "type": "custom"
      },
      {
        "current": {
          "text": "None",
          "value": "None"
        },
        "includeAll": false,
        "label": "Time Grouping",
        "name": "time_grouping",
        "options": [
          {
            "selected": true,
            "text": "None",
            "value": "None"
          },
          {
            "selected": false,
            "text": "Month of Year",
            "value": "month_of_year"
          },
          {
            "selected": false,
            "text": "Year",
            "value": "year"
          }
        ],
        "query": "None : None, Month of Year : month_of_year, Year : year",
        "type": "custom"
      },
      {
        "current": {
          "text": "a6bba32fcf6760fab700171d339f5e29",
          "value": "a6bba32fcf6760fab700171d339f5e29"
        },
        "datasource": {
          "type": "grafana-postgresql-datasource",
          "uid": "bdz3m3xs99p1cf"
        },
        "definition": "select * from md5('summary_metrics_table/2022-12-31_${grid}_lsm_${metric}_${region}_2016-01-01_${time_grouping}_${truth}_tmp2m')",
        "hide": 2,
        "includeAll": false,
        "name": "tmp2m_tab_name",
        "options": [],
        "query": "select * from md5('summary_metrics_table/2022-12-31_${grid}_lsm_${metric}_${region}_2016-01-01_${time_grouping}_${truth}_tmp2m')",
        "refresh": 2,
        "regex": "",
        "type": "query"
      },
      {
        "current": {
          "text": "bea82073c0e1d334d87bc117d059358b",
          "value": "bea82073c0e1d334d87bc117d059358b"
        },
        "datasource": {
          "type": "grafana-postgresql-datasource",
          "uid": "bdz3m3xs99p1cf"
        },
        "definition": "select * from md5('seasonal_metrics_table/2022-12-31_${grid}_lsm_${metric}_${region}_2016-01-01_${time_grouping}_${truth}_tmp2m')",
        "hide": 2,
        "includeAll": false,
        "name": "seasonal_tmp2m_tab_name",
        "options": [],
        "query": "select * from md5('seasonal_metrics_table/2022-12-31_${grid}_lsm_${metric}_${region}_2016-01-01_${time_grouping}_${truth}_tmp2m')",
        "refresh": 2,
        "regex": "",
        "type": "query"
      },
      {
        "current": {
          "text": "fd79c0400c9152148cce3dfea66b5258",
          "value": "fd79c0400c9152148cce3dfea66b5258"
        },
        "datasource": {
          "type": "grafana-postgresql-datasource",
          "uid": "bdz3m3xs99p1cf"
        },
        "definition": "select * from md5('summary_metrics_table/2022-12-31_${grid}_lsm_${metric}_${region}_2016-01-01_${time_grouping}_${truth}_precip')",
        "hide": 2,
        "includeAll": false,
        "name": "precip_tab_name",
        "options": [],
        "query": "select * from md5('summary_metrics_table/2022-12-31_${grid}_lsm_${metric}_${region}_2016-01-01_${time_grouping}_${truth}_precip')",
        "refresh": 2,
        "regex": "",
        "type": "query"
      },
      {
        "current": {
          "text": "1eca5535bb795b3e04344691e128080a",
          "value": "1eca5535bb795b3e04344691e128080a"
        },
        "datasource": {
          "type": "grafana-postgresql-datasource",
          "uid": "bdz3m3xs99p1cf"
        },
        "definition": "select * from md5('seasonal_metrics_table/2022-12-31_${grid}_lsm_${metric}_${region}_2016-01-01_${time_grouping}_${truth}_precip')",
        "hide": 2,
        "includeAll": false,
        "name": "seasonal_precip_tab_name",
        "options": [],
        "query": "select * from md5('seasonal_metrics_table/2022-12-31_${grid}_lsm_${metric}_${region}_2016-01-01_${time_grouping}_${truth}_precip')",
        "refresh": 2,
        "regex": "",
        "type": "query"
      },
      {
        "current": {
          "text": "select v.* from (values ('None')) v(t)",
          "value": "select v.* from (values ('None')) v(t)"
        },
        "datasource": {
          "type": "grafana-postgresql-datasource",
          "uid": "bdz3m3xs99p1cf"
        },
        "definition": "select \nCASE\n    WHEN v.g = 'None' THEN 'select v.* from (values (''None'')) v(t)'\n    ELSE 'select distinct time from \"${precip_tab_name}\"'\nEND\nfrom (values ('$time_grouping')) v(g)",
        "hide": 2,
        "includeAll": false,
        "name": "time_filter_filter_query",
        "options": [],
        "query": "select \nCASE\n    WHEN v.g = 'None' THEN 'select v.* from (values (''None'')) v(t)'\n    ELSE 'select distinct time from \"${precip_tab_name}\"'\nEND\nfrom (values ('$time_grouping')) v(g)",
        "refresh": 1,
        "regex": "",
        "type": "query"
      },
      {
        "current": {
          "text": "None",
          "value": "None"
        },
        "datasource": {
          "type": "grafana-postgresql-datasource",
          "uid": "bdz3m3xs99p1cf"
        },
        "definition": "${time_filter_filter_query:raw}",
        "includeAll": false,
        "label": "Time Filter",
        "name": "time_filter",
        "options": [],
        "query": "${time_filter_filter_query:raw}",
        "refresh": 1,
        "regex": "",
        "sort": 3,
        "type": "query"
      },
      {
        "current": {
          "text": "",
          "value": ""
        },
        "datasource": {
          "type": "grafana-postgresql-datasource",
          "uid": "bdz3m3xs99p1cf"
        },
        "definition": "select \nCASE\n    WHEN v.g = 'None' THEN ''\n    ELSE 'where time = ' || v.t\nEND\nfrom (values ('$time_filter', '$time_grouping')) v(t, g)",
        "hide": 2,
        "includeAll": false,
        "name": "time_filter_query",
        "options": [],
        "query": "select \nCASE\n    WHEN v.g = 'None' THEN ''\n    ELSE 'where time = ' || v.t\nEND\nfrom (values ('$time_filter', '$time_grouping')) v(t, g)",
        "refresh": 1,
        "regex": "",
        "type": "query"
      },
      {
        "current": {
          "text": "df42c3e5e8224971743b1c1b16715dad",
          "value": "df42c3e5e8224971743b1c1b16715dad"
        },
        "datasource": {
          "type": "grafana-postgresql-datasource",
          "uid": "bdz3m3xs99p1cf"
        },
        "definition": "select * from md5('biweekly_summary_metrics_table/2022-12-31_${grid}_lsm_${metric}_${region}_2016-01-01_${time_grouping}_${truth}_tmp2m')",
        "hide": 2,
        "includeAll": false,
        "name": "tmp2m_tab_name_biweekly",
        "options": [],
        "query": "select * from md5('biweekly_summary_metrics_table/2022-12-31_${grid}_lsm_${metric}_${region}_2016-01-01_${time_grouping}_${truth}_tmp2m')",
        "refresh": 2,
        "regex": "",
        "type": "query"
      },
      {
        "current": {
          "text": "04355701a978c6b03dfda76c1f601b2f",
          "value": "04355701a978c6b03dfda76c1f601b2f"
        },
        "datasource": {
          "type": "grafana-postgresql-datasource",
          "uid": "bdz3m3xs99p1cf"
        },
        "definition": "select * from md5('biweekly_summary_metrics_table/2022-12-31_${grid}_lsm_${metric}_${region}_2016-01-01_${time_grouping}_${truth}_precip')",
        "hide": 2,
        "includeAll": false,
        "name": "precip_tab_name_biweekly",
        "options": [],
        "query": "select * from md5('biweekly_summary_metrics_table/2022-12-31_${grid}_lsm_${metric}_${region}_2016-01-01_${time_grouping}_${truth}_precip')",
        "refresh": 2,
        "regex": "",
        "type": "query"
      },
      {
        "current": {
          "text": "fd79c0400c9152148cce3dfea66b5258",
          "value": "fd79c0400c9152148cce3dfea66b5258"
        },
        "datasource": {
          "type": "grafana-postgresql-datasource",
          "uid": "bdz3m3xs99p1cf"
        },
        "definition": "select * from md5('summary_metrics_table/2022-12-31_${grid}_lsm_${metric}_${region}_2016-01-01_${time_grouping}_${truth}_precip')",
        "hide": 2,
        "includeAll": false,
        "name": "precip_tab_name_baseline",
        "options": [],
        "query": "select * from md5('summary_metrics_table/2022-12-31_${grid}_lsm_${metric}_${region}_2016-01-01_${time_grouping}_${truth}_precip')",
        "refresh": 2,
        "regex": "",
        "type": "query"
      }
    ]
  },
  "time": {
    "from": "now-6h",
    "to": "now"
  },
  "timepicker": {
    "hidden": true
  },
  "timezone": "utc",
  "title": "Aim for Scale Benchmarking",
  "uid": "eeu7f55ajbvnkb",
  "version": 5,
  "weekStart": ""
}

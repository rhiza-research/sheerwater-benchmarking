{
  "annotations": {
    "list": [
      {
        "builtIn": 1,
        "datasource": {
          "type": "grafana",
          "uid": "-- Grafana --"
        },
        "enable": true,
        "hide": true,
        "iconColor": "rgba(0, 211, 255, 1)",
        "name": "Annotations & Alerts",
        "type": "dashboard"
      }
    ]
  },
  "editable": true,
  "fiscalYearStartMonth": 0,
  "graphTooltip": 0,
  "id": 20,
  "links": [],
  "panels": [
    {
      "datasource": {
        "default": true,
        "type": "grafana-postgresql-datasource",
        "uid": "bdz3m3xs99p1cf"
      },
      "fieldConfig": {
        "defaults": {
          "color": {
            "mode": "thresholds"
          },
          "custom": {
            "hideFrom": {
              "legend": false,
              "tooltip": false,
              "viz": false
            }
          },
          "links": [
            {
              "targetBlank": false,
              "title": "View Location",
              "url": "/d/becpaz5nsxr7kc?var-lat=${__data.fields[0]}&var-lon=${__data.fields[1]}&${__all_variables}\n\n\n"
            }
          ],
          "mappings": [],
          "thresholds": {
            "mode": "absolute",
            "steps": [
              {
                "color": "green",
                "value": null
              },
              {
                "color": "red",
                "value": 80
              }
            ]
          }
        },
        "overrides": [
          {
            "matcher": {
              "id": "byType",
              "options": "number"
            },
            "properties": [
              {
                "id": "decimals",
                "value": 2
              }
            ]
          }
        ]
      },
      "gridPos": {
        "h": 16,
        "w": 7,
        "x": 0,
        "y": 0
      },
      "id": 7,
      "options": {
        "basemap": {
          "config": {},
          "name": "Layer 0",
          "type": "default"
        },
        "controls": {
          "mouseWheelZoom": true,
          "showAttribution": false,
          "showDebug": false,
          "showMeasure": false,
          "showScale": false,
          "showZoom": true
        },
        "layers": [
          {
            "config": {
              "showLegend": false,
              "style": {
                "color": {
                  "fixed": "super-light-purple"
                },
                "opacity": 0.4,
                "rotation": {
                  "fixed": 0,
                  "max": 360,
                  "min": -360,
                  "mode": "mod"
                },
                "size": {
                  "fixed": 6,
                  "max": 15,
                  "min": 2
                },
                "symbol": {
                  "fixed": "img/icons/marker/square.svg",
                  "mode": "fixed"
                },
                "symbolAlign": {
                  "horizontal": "center",
                  "vertical": "center"
                },
                "textConfig": {
                  "fontSize": 12,
                  "offsetX": 0,
                  "offsetY": 0,
                  "textAlign": "center",
                  "textBaseline": "middle"
                }
              }
            },
            "location": {
              "latitude": "latitude",
              "longitude": "longitude",
              "mode": "coords"
            },
            "name": "Layer 1",
            "tooltip": true,
            "type": "markers"
          },
          {
            "config": {
              "showLegend": false,
              "style": {
                "color": {
                  "fixed": "dark-blue"
                },
                "opacity": 0.4,
                "rotation": {
                  "fixed": 0,
                  "max": 360,
                  "min": -360,
                  "mode": "mod"
                },
                "size": {
                  "fixed": 6,
                  "max": 15,
                  "min": 2
                },
                "symbol": {
                  "fixed": "img/icons/marker/square.svg",
                  "mode": "fixed"
                },
                "symbolAlign": {
                  "horizontal": "center",
                  "vertical": "center"
                },
                "textConfig": {
                  "fontSize": 12,
                  "offsetX": 0,
                  "offsetY": 0,
                  "textAlign": "center",
                  "textBaseline": "middle"
                }
              }
            },
            "filterData": {
              "id": "byRefId",
              "options": "B"
            },
            "location": {
              "mode": "auto"
            },
            "name": "Layer 2",
            "tooltip": false,
            "type": "markers"
          }
        ],
        "tooltip": {
          "mode": "details"
        },
        "view": {
          "allLayers": true,
          "id": "coords",
          "lat": 0,
          "lon": 38,
          "zoom": 5
        }
      },
      "pluginVersion": "11.5.0-pre",
      "targets": [
        {
          "datasource": {
            "type": "grafana-postgresql-datasource",
            "uid": "bdz3m3xs99p1cf"
          },
          "editorMode": "code",
          "format": "table",
          "rawQuery": true,
          "rawSql": "SELECT DISTINCT lat as latitude, lon as longitude\nFROM \"$rainfall_tab_name\"\nWHERE precip_1d IS NOT NULL;",
          "refId": "A",
          "sql": {
            "columns": [
              {
                "parameters": [],
                "type": "function"
              }
            ],
            "groupBy": [
              {
                "property": {
                  "type": "string"
                },
                "type": "groupBy"
              }
            ],
            "limit": 50
          }
        },
        {
          "datasource": {
            "type": "grafana-postgresql-datasource",
            "uid": "bdz3m3xs99p1cf"
          },
          "editorMode": "code",
          "format": "table",
          "hide": false,
          "rawQuery": true,
          "rawSql": "SELECT ${lat} as lat, ${lon} as lon",
          "refId": "B",
          "sql": {
            "columns": [
              {
                "parameters": [],
                "type": "function"
              }
            ],
            "groupBy": [
              {
                "property": {
                  "type": "string"
                },
                "type": "groupBy"
              }
            ],
            "limit": 50
          }
        }
      ],
      "title": "Select Location",
      "type": "geomap"
    },
    {
      "datasource": {
        "default": true,
        "type": "grafana-postgresql-datasource",
        "uid": "bdz3m3xs99p1cf"
      },
      "fieldConfig": {
        "defaults": {},
        "overrides": [
          {
            "matcher": {
              "id": "byName",
              "options": "forecast"
            },
            "properties": []
          },
          {
            "matcher": {
              "id": "byName",
              "options": "forecast"
            },
            "properties": []
          }
        ]
      },
      "gridPos": {
        "h": 8,
        "w": 17,
        "x": 7,
        "y": 0
      },
      "id": 6,
      "options": {
        "allData": {},
        "config": {},
        "data": [],
        "imgFormat": "png",
        "layout": {
          "barmode": "group",
          "font": {
            "family": "Inter, Helvetica, Arial, sans-serif"
          },
          "hoverlabel": {
            "bgcolor": "rgba(255, 255, 255, 0.95)"
          },
          "hovermode": "x unified",
          "margin": {
            "b": 30,
            "l": 40,
            "r": 10,
            "t": 5
          },
          "modebar": {
            "activecolor": "grey",
            "bgcolor": "rgba(255, 255, 255, 0)",
            "color": "lightgray",
            "orientation": "v",
            "remove": [
              "zoom2d",
              "pan2d",
              "select2d",
              "lasso2d",
              "zoomIn2d",
              "zoomOut2d"
            ]
          },
          "paper_bgcolor": "white",
          "plot_bgcolor": "white",
          "title": {
            "automargin": true
          },
          "xaxis": {
            "automargin": true,
            "autorange": false,
            "tickfont": {
              "size": 14
            },
            "ticklen": 4,
            "tickwidth": 1,
            "type": "date"
          },
          "yaxis": {
            "automargin": true,
            "autorange": false,
            "gridcolor": "rgba(0, 0, 0, 0.15)",
            "range": [
              -10,
              120
            ],
            "rangemode": "tozero",
            "tickfont": {
              "size": 14
            },
            "title": {
              "font": {
                "size": 16
              },
              "standoff": 20,
              "text": "Precipitation (mm)"
            },
            "type": "linear"
          }
        },
        "onclick": "// Event handling\n/*\n// 'data', 'variables', 'options', 'utils', and 'event' are passed as arguments\n\ntry {\n  const { type: eventType, data: eventData } = event;\n  const { timeZone, dayjs, locationService, getTemplateSrv } = utils;\n\n  switch (eventType) {\n    case 'click':\n      console.log('Click event:', eventData.points);\n      break;\n    case 'select':\n      console.log('Selection event:', eventData.range);\n      break;\n    case 'zoom':\n      console.log('Zoom event:', eventData);\n      break;\n    default:\n      console.log('Unhandled event type:', eventType, eventData);\n  }\n\n  console.log('Current time zone:', timeZone);\n  console.log('From time:', dayjs(variables.__from).format());\n  console.log('To time:', dayjs(variables.__to).format());\n\n  // Example of using locationService\n  // locationService.partial({ 'var-example': 'test' }, true);\n\n} catch (error) {\n  console.error('Error in onclick handler:', error);\n}\n*/\n  ",
        "resScale": 2,
        "script": "// Helper function to check if field has values\nfunction hasValues(field) {\n    return field && field.values && field.values.length > 0;\n}\n\n// Helper function to get field values\nfunction getValues(field) {\n    return field.values || field.values.buffer;\n}\n\n// Add viridis color mapping function\nfunction getViridisColor(value, min, max) {\n    const viridisColors = [\n        '#440154', '#443982', '#31688e', '#21918c', '#35b779', '#90d743', '#fde725'\n    ];\n    const normalizedValue = (value - min) / (max - min);\n    const index = Math.floor(normalizedValue * (viridisColors.length - 1));\n    return viridisColors[Math.min(viridisColors.length - 1, Math.max(0, index))];\n}\n\nlet traces = [];\nlet shapes_verify = [];\nlet shapes_fcst = [];\nlet shapes_ltn = [];   \nconst rain_primary = data.series[0];\nconst rain_secondary = data.series[1];\nconst truth_onset = data.series[2];\nconst forecast_onset = data.series[3];\nconst ltn_onset = data.series[4];\n\nconst year = Number(variables.verify_year.current.value);\nconst yearStart = new Date(year, 0, 1).getTime();\nconst yearEnd = new Date(year, 11, 31).getTime();\nconst show_compare = Boolean(variables.compare.current.value == \"True\");\n\n// Get time range for threshold lines (if time series exists)\nlet timeRange = [];\nif (hasValues(rain_primary.fields[0])) {\n    const timeValues = getValues(rain_primary.fields[0]);\n    timeRange = [Math.min(...timeValues), Math.max(...timeValues)];\n}\n\n// Define trace configurations for precipitation data\nconst traceConfigs = [\n    {\n        data: rain_primary.fields[1], // daily precip\n        name: \"Daily Precip\",\n        color: '#4A90E2',\n        mode: 'markers',\n        marker: {\n            symbol: 'circle'\n        }    \n    },    \n    {\n        data: rain_primary.fields[2], // precip_8d\n        name: \"Precip 8d\",\n        color: '#F5A7B8',\n        // color: '#6C7B56',\n        mode: 'lines'\n    },\n    // {\n    //     data: rain_primary.fields[3], // precip_11d\n    //     name: \"Precip 11d\",\n    //     color: '#F5A7B8',\n    //     mode: 'lines'\n    // },\n];\n\nif (show_compare) {\n    traceConfigs.push(\n        {\n            data: rain_secondary.fields[2],\n            name: \"Compare Precip 8d\",\n            color: '#4A3244',\n            mode: 'lines'\n        },\n        // {\n        //     data: rain_secondary.fields[3],\n        //     name: \"Compare Precip 11d\",\n        //     color: '#722F37',\n        //     mode: 'lines'\n        // }         \n    );\n}\n\n// Add precipitation traces if they have data\ntraceConfigs.forEach(config => {\n    if (hasValues(config.data)) {\n        traces.push({\n            x: getValues(rain_primary.fields[0]),\n            y: getValues(config.data),\n            type: 'scatter',\n            mode: config.mode,\n            name: config.name,\n            marker: {\n                size: 6,\n            },\n            line: { color: config.color }\n        });\n    }\n});\n\n// Add threshold lines if we have a time range\nif (timeRange.length) {\n    const thresholds = [\n        // { value: 30, name: 'Threshold 30', color: '#6C7B56', dash: 'dash' },\n        { value: 30, name: 'Threshold 30', color: '#F5A7B8', dash: 'dash' },\n        // { value: 40, name: 'Threshold 40', color: '#F5A7B8', dash: 'dashdot' }\n    ];\n\n    thresholds.forEach(threshold => {\n        traces.push({\n            x: timeRange,\n            y: [threshold.value, threshold.value],\n            type: 'scatter',\n            mode: 'lines',\n            name: threshold.name,\n            line: {\n                color: threshold.color,\n                width: 2,\n                dash: threshold.dash\n            }\n        });\n    });\n}\n    // Process forecast onset dates with leads (converting seconds to days)\n// if (hasValues(forecast_onset?.fields[0])) {\n//     const leadValues = getValues(forecast_onset.fields[1]).map(lead => lead / 86400 / 1_000_000_000);  // Convert seconds to days\n//     const onsetDates = getValues(forecast_onset.fields[2]);  // forecast onset dates\n//     const uniqueLeads = [...new Set(leadValues)].sort((a, b) => a - b);\n    \n//     uniqueLeads.forEach(lead => {\n//         const leadIndices = leadValues.map((v, i) => v === lead ? i : -1).filter(i => i !== -1);\n//         const leadTimes = leadIndices.map(i => onsetDates[i]);  // Use onset dates instead of issue times\n//         const color = getViridisColor(lead, Math.min(...uniqueLeads), Math.max(...uniqueLeads));\n\n//         traces.push({\n//             x: leadTimes,\n//             y: Array(leadTimes.length).fill(0),\n//             type: 'scatter',\n//             mode: 'markers',\n//             name: `Forecast Lead ${lead.toFixed(0)} days`,\n//             marker: {\n//                 symbol: 'x',\n//                 color: color,\n//                 size: 10\n//             }\n//         });\n        \n//         shapes_fcst =  shapes_fcst.concat(\n//             leadTimes.map(time => ({\n//                 type: 'line',\n//                 x0: time,\n//                 x1: time,\n//                 y0: 0,\n//                 y1: 1,\n//                 xref: 'x',\n//                 yref: 'paper',\n//                 line: {\n//                     color: color,\n//                     width: 1,\n//                     dash: 'solid'\n//                 }\n//             }))\n//         );\n//     });\n// }\n\n\n// Process onset dates\nconst onsets = truth_onset?.fields[0];\nif (hasValues(onsets)) {\n    const onsetDates = getValues(onsets).map(timestamp => new Date(timestamp));\n    \n    // Separate verification year dates and historical dates\n    const dates_verify = [];\n    const historicalDates = [];\n    \n    onsetDates.forEach(date => {\n        if (date.getFullYear() === year) {\n            dates_verify.push(date);\n        } else {\n            const normalizedDate = new Date(year, date.getMonth(), date.getDate());\n            historicalDates.push(normalizedDate);\n        }\n    });\n\n    // Add historical onset markers (black)\n    if (historicalDates.length > 0  && false ) {\n        traces.push({\n            x: historicalDates,\n            y: Array(historicalDates.length).fill(0),\n            type: 'scatter',\n            mode: 'markers',\n            name: 'Historical Onsets',\n            marker: {\n                color: 'black',\n                symbol: 'x',\n                size: 10\n            }\n        });\n    }\n\n    // Add verify year onset markers (red)\n    if (dates_verify.length > 0) {\n        traces.push({\n            x: dates_verify,\n            y: Array(dates_verify.length).fill(0),\n            type: 'scatter',\n            mode: 'markers',\n            name: `${year} Onsets`,\n            marker: {\n                color: 'red',\n                symbol: 'x',\n                size: 10\n            }\n        });\n    }\n\n    // Create vertical lines for verify dates (red)\n    shapes_verify = dates_verify.map(date => ({\n        type: 'line',\n        x0: date,\n        x1: date,\n        y0: 0,\n        y1: 1,\n        xref: 'x',\n        yref: 'paper',\n        line: {\n            color: 'red',\n            width: 1,\n            dash: 'solid'\n        }\n    }));\n}\n\n// Process ltn onset dates\nconst ltn_onsets = ltn_onset?.fields[0];\nif (hasValues(ltn_onsets) && false) {\n    const ltnOnsetDates = getValues(ltn_onsets).map(timestamp => new Date(timestamp));\n    \n    const ltnDates = [];\n    \n    ltnOnsetDates.forEach(date => {\n        const ltnDate = new Date(year, date.getMonth(), date.getDate());\n        ltnDates.push(ltnDate);\n    });\n\n    if (ltnDates.length > 0) {\n        traces.push({\n            x: ltnDates,\n            y: Array(ltnDates.length).fill(0),\n            type: 'scatter',\n            mode: 'markers',\n            name: '2004-2015 LTN Onset',\n            marker: {\n                color: 'gold',\n                symbol: 'x',\n                size: 10\n            }\n        });\n    }\n\n    shapes_ltn = ltnDates.map(date => ({\n        type: 'line',\n        x0: date,\n        x1: date,\n        y0: 0,\n        y1: 1,\n        xref: 'x',\n        yref: 'paper',\n        line: {\n            color: 'gold',\n            width: 1,\n            dash: 'solid'\n        }\n    }));\n}\n\nreturn {\n    data: traces,\n    layout: {\n        shapes: [...shapes_verify],\n        // shapes: [...shapes_fcst, ...shapes_verify],\n        xaxis: {\n            range: [yearStart, yearEnd],\n            type: 'date',\n            title: 'Time'\n        },        \n        yaxis: { \n            title: 'Precipitation (mm)'\n        },\n        showlegend: true\n    }\n};",
        "syncTimeRange": false,
        "timeCol": ""
      },
      "pluginVersion": "1.8.1",
      "targets": [
        {
          "datasource": {
            "type": "grafana-postgresql-datasource",
            "uid": "bdz3m3xs99p1cf"
          },
          "editorMode": "code",
          "format": "table",
          "rawQuery": true,
          "rawSql": "SELECT \"time\", \"precip_1d\", \"precip_8d\", \"precip_11d\"\nFROM \"$rainfall_tab_name\"\nWHERE lat = ${lat} \n  AND lon = ${lon}\n  AND EXTRACT(YEAR FROM \"time\") IN (${verify_year})\n  AND (precip_1d IS NOT NULL OR precip_8d IS NOT NULL OR precip_11d IS NOT NULL)\nORDER BY \"time\";",
          "refId": "A",
          "sql": {
            "columns": [
              {
                "parameters": [],
                "type": "function"
              }
            ],
            "groupBy": [
              {
                "property": {
                  "type": "string"
                },
                "type": "groupBy"
              }
            ],
            "limit": 50
          }
        },
        {
          "datasource": {
            "type": "grafana-postgresql-datasource",
            "uid": "bdz3m3xs99p1cf"
          },
          "editorMode": "code",
          "format": "table",
          "hide": false,
          "rawQuery": true,
          "rawSql": "SELECT \"time\", \"precip_1d\", \"precip_8d\", \"precip_11d\"\nFROM \"$rainfall2_tab_name\"\nWHERE lat = ${lat} \n  AND lon = ${lon}\n  AND EXTRACT(YEAR FROM \"time\") IN (${verify_year})\n  AND (precip_1d IS NOT NULL OR precip_8d IS NOT NULL OR precip_11d IS NOT NULL)\nORDER BY \"time\";",
          "refId": "B",
          "sql": {
            "columns": [
              {
                "parameters": [],
                "type": "function"
              }
            ],
            "groupBy": [
              {
                "property": {
                  "type": "string"
                },
                "type": "groupBy"
              }
            ],
            "limit": 50
          }
        },
        {
          "datasource": {
            "type": "grafana-postgresql-datasource",
            "uid": "bdz3m3xs99p1cf"
          },
          "editorMode": "code",
          "format": "table",
          "hide": false,
          "rawQuery": true,
          "rawSql": "SELECT \"rainy_onset\"\nFROM \"$onset_tab_name\"\nWHERE lat = ${lat} \n  AND lon = ${lon}\nORDER BY \"rainy_onset\";",
          "refId": "C",
          "sql": {
            "columns": [
              {
                "parameters": [],
                "type": "function"
              }
            ],
            "groupBy": [
              {
                "property": {
                  "type": "string"
                },
                "type": "groupBy"
              }
            ],
            "limit": 50
          }
        },
        {
          "datasource": {
            "type": "grafana-postgresql-datasource",
            "uid": "bdz3m3xs99p1cf"
          },
          "editorMode": "code",
          "format": "table",
          "hide": false,
          "rawQuery": true,
          "rawSql": "SELECT time, lead_time, rainy_onset\nFROM \"$fcst_onset_tab_name\"\nWHERE lat = ${lat} \n  AND lon = ${lon}\n  AND EXTRACT(YEAR FROM \"time\") IN (${verify_year})\nORDER BY \"time\", \"lead_time\";",
          "refId": "D",
          "sql": {
            "columns": [
              {
                "parameters": [],
                "type": "function"
              }
            ],
            "groupBy": [
              {
                "property": {
                  "type": "string"
                },
                "type": "groupBy"
              }
            ],
            "limit": 50
          }
        },
        {
          "datasource": {
            "type": "grafana-postgresql-datasource",
            "uid": "bdz3m3xs99p1cf"
          },
          "editorMode": "code",
          "format": "table",
          "hide": false,
          "rawQuery": true,
          "rawSql": "-- SELECT \"rainy_onset\"\n-- FROM \"$ltn_onset_tab_name\"\n-- WHERE lat = ${lat} \n--   AND lon = ${lon}\n-- ORDER BY \"rainy_onset\";",
          "refId": "E",
          "sql": {
            "columns": [
              {
                "parameters": [],
                "type": "function"
              }
            ],
            "groupBy": [
              {
                "property": {
                  "type": "string"
                },
                "type": "groupBy"
              }
            ],
            "limit": 50
          }
        },
        {
          "datasource": {
            "type": "grafana-postgresql-datasource",
            "uid": "bdz3m3xs99p1cf"
          },
          "editorMode": "code",
          "format": "table",
          "hide": false,
          "rawQuery": true,
          "rawSql": "-- Put these here, so refresh is done\n-- select \"$compare\" \"$ltn\" \"$forecast\" ",
          "refId": "F",
          "sql": {
            "columns": [
              {
                "parameters": [],
                "type": "function"
              }
            ],
            "groupBy": [
              {
                "property": {
                  "type": "string"
                },
                "type": "groupBy"
              }
            ],
            "limit": 50
          }
        }
      ],
      "title": "Daily Rainfall (mm)",
      "transparent": true,
      "type": "nline-plotlyjs-panel"
    },
    {
      "datasource": {
        "default": true,
        "type": "grafana-postgresql-datasource",
        "uid": "bdz3m3xs99p1cf"
      },
      "fieldConfig": {
        "defaults": {},
        "overrides": [
          {
            "matcher": {
              "id": "byName",
              "options": "forecast"
            },
            "properties": []
          },
          {
            "matcher": {
              "id": "byName",
              "options": "forecast"
            },
            "properties": []
          }
        ]
      },
      "gridPos": {
        "h": 8,
        "w": 17,
        "x": 7,
        "y": 8
      },
      "id": 10,
      "options": {
        "allData": {},
        "config": {},
        "data": [],
        "imgFormat": "png",
        "layout": {
          "barmode": "group",
          "font": {
            "family": "Inter, Helvetica, Arial, sans-serif"
          },
          "hoverlabel": {
            "bgcolor": "rgba(255, 255, 255, 0.95)"
          },
          "hovermode": "x unified",
          "margin": {
            "b": 30,
            "l": 40,
            "r": 10,
            "t": 5
          },
          "modebar": {
            "activecolor": "grey",
            "bgcolor": "rgba(255, 255, 255, 0)",
            "color": "lightgray",
            "orientation": "v",
            "remove": [
              "zoom2d",
              "pan2d",
              "select2d",
              "lasso2d",
              "zoomIn2d",
              "zoomOut2d"
            ]
          },
          "paper_bgcolor": "white",
          "plot_bgcolor": "white",
          "title": {
            "automargin": true
          },
          "xaxis": {
            "automargin": true,
            "autorange": false,
            "tickfont": {
              "size": 14
            },
            "ticklen": 4,
            "tickwidth": 1,
            "type": "date"
          },
          "yaxis": {
            "automargin": true,
            "autorange": false,
            "gridcolor": "rgba(0, 0, 0, 0.15)",
            "range": [
              -0.1,
              1
            ],
            "rangemode": "tozero",
            "tickfont": {
              "size": 14
            },
            "title": {
              "font": {
                "size": 16
              },
              "standoff": 20,
              "text": "Precipitation (mm)"
            },
            "type": "linear"
          }
        },
        "onclick": "// Event handling\n/*\n// 'data', 'variables', 'options', 'utils', and 'event' are passed as arguments\n\ntry {\n  const { type: eventType, data: eventData } = event;\n  const { timeZone, dayjs, locationService, getTemplateSrv } = utils;\n\n  switch (eventType) {\n    case 'click':\n      console.log('Click event:', eventData.points);\n      break;\n    case 'select':\n      console.log('Selection event:', eventData.range);\n      break;\n    case 'zoom':\n      console.log('Zoom event:', eventData);\n      break;\n    default:\n      console.log('Unhandled event type:', eventType, eventData);\n  }\n\n  console.log('Current time zone:', timeZone);\n  console.log('From time:', dayjs(variables.__from).format());\n  console.log('To time:', dayjs(variables.__to).format());\n\n  // Example of using locationService\n  // locationService.partial({ 'var-example': 'test' }, true);\n\n} catch (error) {\n  console.error('Error in onclick handler:', error);\n}\n*/\n  ",
        "resScale": 2,
        "script": "// Helper functions remain the same\nfunction hasValues(field) {\n    return field && field.values && field.values.length > 0;\n}\n\nfunction getValues(field) {\n    return field.values || field.values.buffer;\n}\n\n// Get panel variables\nconst year = Number(variables.verify_year.current.value);\nconst groupByLeadTime = (variables.group_by_lead_time.current.value).toLowerCase() === \"true\";\nconst yearStart = new Date(year, 0, 1).getTime();\nconst yearEnd = new Date(year, 11, 31).getTime();\n\nlet series1 = data.series[0];\nlet series2 = data.series[1];\n\nlet start_time = series1.fields[0];\nlet lead = series1.fields[1];\nlet prob_onset = series1.fields[2];\n\n// Viridis color map values (sampled at regular intervals)\nconst viridisColors = [\n    '#440154', '#481567', '#482677', '#453781', '#404788', '#39568C', '#33638D',\n    '#2D708E', '#287D8E', '#238A8D', '#1F968B', '#20A387', '#29AF7F', '#3CBB75',\n    '#55C667', '#73D055', '#95D840', '#B8DE29', '#DCE319', '#FDE725'\n];\n\nlet traces = [];\n\nif (groupByLeadTime) {\n    // Original grouping by lead time logic\n    let leadTimeMap = new Map();\n\n    // Group data points by lead time\n    for (let i = 0; i < lead.values.length; i++) {\n        const leadTime = lead.values[i];\n        if (!leadTimeMap.has(leadTime)) {\n            leadTimeMap.set(leadTime, {\n                x: [],\n                y: []\n            });\n        }\n        const forecastTime = start_time.values[i] + (leadTime / 1_000_000);\n        leadTimeMap.get(leadTime).x.push(forecastTime);\n        leadTimeMap.get(leadTime).y.push(prob_onset.values[i]);\n    }\n\n    // Get sorted unique lead times\n    const sortedLeadTimes = Array.from(leadTimeMap.keys()).sort((a, b) => a - b);\n\n    // Create traces for each lead time\n    traces = sortedLeadTimes.map((leadTime, index) => {\n        const points = leadTimeMap.get(leadTime);\n        const sortedIndices = points.x.map((_, i) => i)\n            .sort((a, b) => points.x[a] - points.x[b]);\n\n        const colorIndex = Math.floor((index / (sortedLeadTimes.length - 1)) * (viridisColors.length - 1));\n        const leadTimeDays = Math.round(leadTime / (1000000 * 60 * 60 * 24));\n\n        return {\n            x: sortedIndices.map(i => points.x[i]),\n            y: sortedIndices.map(i => points.y[i]),\n            type: 'scatter',\n            mode: 'lines',\n            name: `Lead: ${leadTimeDays / 1000} days`,\n            line: {\n                color: viridisColors[colorIndex]\n            }\n        };\n    });\n} else {\n    // Group by start date\n    let startDateMap = new Map();\n\n    // Group data points by start date\n    for (let i = 0; i < start_time.values.length; i++) {\n        const startTimeValue = start_time.values[i];\n        const startDate = new Date(startTimeValue).toISOString().split('T')[0];\n\n        if (!startDateMap.has(startDate)) {\n            startDateMap.set(startDate, {\n                x: [],\n                y: [],\n                leads: []\n            });\n        }\n        const forecastTime = startTimeValue + (lead.values[i] / 1_000_000);\n        startDateMap.get(startDate).x.push(forecastTime);\n        startDateMap.get(startDate).y.push(prob_onset.values[i]);\n        startDateMap.get(startDate).leads.push(lead.values[i]);\n    }\n\n    // Get sorted unique start dates\n    const sortedStartDates = Array.from(startDateMap.keys()).sort();\n\n    // Create traces for each start date\n    traces = sortedStartDates.map((startDate, index) => {\n        const points = startDateMap.get(startDate);\n        const sortedIndices = points.x.map((_, i) => i)\n            .sort((a, b) => points.x[a] - points.x[b]);\n\n        const colorIndex = Math.floor((index / (sortedStartDates.length - 1)) * (viridisColors.length - 1));\n\n        return {\n            x: sortedIndices.map(i => points.x[i]),\n            y: sortedIndices.map(i => points.y[i]),\n            type: 'scatter',\n            mode: 'lines',\n            name: `Start: ${startDate}`,\n            line: {\n                color: viridisColors[colorIndex]\n            }\n        };\n    });\n}\n\n// Add onsets if they exist\nconst onsets = series2?.fields[0];\nif (hasValues(onsets)) {\n    // Add onset markers\n    traces.push({\n        x: getValues(onsets),\n        y: Array(onsets.values.length).fill(0),\n        type: 'scatter',\n        mode: 'markers',\n        name: `${year} Onsets`,\n        marker: {\n            color: 'red',\n            symbol: 'x',\n            size: 10\n        }\n    });\n\n    // Create vertical lines for onsets\n    const shapes = getValues(onsets).map(timestamp => ({\n        type: 'line',\n        x0: timestamp,\n        x1: timestamp,\n        y0: 0,\n        y1: 1,\n        xref: 'x',\n        yref: 'paper',\n        line: {\n            color: 'red',\n            width: 1,\n            dash: 'solid'\n        }\n    }));\n\n    return {\n        data: traces,\n        layout: {\n            shapes,\n            xaxis: {\n                range: [yearStart, yearEnd],\n                type: 'date',\n                title: 'Time'\n            },\n            yaxis: {\n                range: [0, 1],\n                title: 'Probability'\n            }\n        }\n    };\n}\n\nreturn {\n    data: traces,\n    layout: {\n        xaxis: {\n            range: [yearStart, yearEnd],\n            type: 'date',\n            title: 'Time'\n        },\n        yaxis: {\n            range: [0, 1],\n            title: 'Probability'\n        }\n    }\n};",
        "syncTimeRange": false,
        "timeCol": ""
      },
      "pluginVersion": "1.8.1",
      "targets": [
        {
          "datasource": {
            "type": "grafana-postgresql-datasource",
            "uid": "bdz3m3xs99p1cf"
          },
          "editorMode": "code",
          "format": "table",
          "hide": false,
          "rawQuery": true,
          "rawSql": "SELECT start_date, lead_time, rainy_forecast\nFROM \"$onset_fcst_tab_name\"\nWHERE lat = ${lat} \n  AND lon = ${lon}\n  AND EXTRACT(YEAR FROM \"start_date\") IN (${verify_year})\n  AND lead_time < 3110400000000000\nORDER BY \"start_date\", \"lead_time\";",
          "refId": "B",
          "sql": {
            "columns": [
              {
                "parameters": [],
                "type": "function"
              }
            ],
            "groupBy": [
              {
                "property": {
                  "type": "string"
                },
                "type": "groupBy"
              }
            ],
            "limit": 50
          }
        },
        {
          "datasource": {
            "type": "grafana-postgresql-datasource",
            "uid": "bdz3m3xs99p1cf"
          },
          "editorMode": "code",
          "format": "table",
          "hide": false,
          "rawQuery": true,
          "rawSql": "SELECT \"rainy_onset\"\nFROM \"$onset_tab_name\"\nWHERE lat = ${lat} \n  AND lon = ${lon}\n  AND EXTRACT(YEAR FROM \"time\") IN (${verify_year})\nORDER BY \"rainy_onset\";",
          "refId": "C",
          "sql": {
            "columns": [
              {
                "parameters": [],
                "type": "function"
              }
            ],
            "groupBy": [
              {
                "property": {
                  "type": "string"
                },
                "type": "groupBy"
              }
            ],
            "limit": 50
          }
        },
        {
          "datasource": {
            "type": "grafana-postgresql-datasource",
            "uid": "bdz3m3xs99p1cf"
          },
          "editorMode": "code",
          "format": "table",
          "hide": false,
          "rawQuery": true,
          "rawSql": "-- dummy query to ensure that plot refreshes when the variable changes\nSELECT $group_by_lead_time",
          "refId": "A",
          "sql": {
            "columns": [
              {
                "parameters": [],
                "type": "function"
              }
            ],
            "groupBy": [
              {
                "property": {
                  "type": "string"
                },
                "type": "groupBy"
              }
            ],
            "limit": 50
          }
        }
      ],
      "title": "Daily Rainfall (mm)",
      "transparent": true,
      "type": "nline-plotlyjs-panel"
    },
    {
      "datasource": {
        "default": true,
        "type": "grafana-postgresql-datasource",
        "uid": "bdz3m3xs99p1cf"
      },
      "fieldConfig": {
        "defaults": {},
        "overrides": [
          {
            "matcher": {
              "id": "byName",
              "options": "forecast"
            },
            "properties": []
          },
          {
            "matcher": {
              "id": "byName",
              "options": "forecast"
            },
            "properties": []
          }
        ]
      },
      "gridPos": {
        "h": 7,
        "w": 24,
        "x": 0,
        "y": 16
      },
      "id": 9,
      "options": {
        "allData": {},
        "config": {},
        "data": [],
        "imgFormat": "png",
        "layout": {
          "barmode": "group",
          "font": {
            "family": "Inter, Helvetica, Arial, sans-serif"
          },
          "hoverlabel": {
            "bgcolor": "rgba(255, 255, 255, 0.95)"
          },
          "hovermode": "x unified",
          "margin": {
            "b": 30,
            "l": 40,
            "r": 10,
            "t": 5
          },
          "modebar": {
            "activecolor": "grey",
            "bgcolor": "rgba(255, 255, 255, 0)",
            "color": "lightgray",
            "orientation": "v",
            "remove": [
              "zoom2d",
              "pan2d",
              "select2d",
              "lasso2d",
              "zoomIn2d",
              "zoomOut2d"
            ]
          },
          "paper_bgcolor": "white",
          "plot_bgcolor": "white",
          "title": {
            "automargin": true
          },
          "xaxis": {
            "automargin": true,
            "autorange": false,
            "tickfont": {
              "size": 14
            },
            "ticklen": 4,
            "tickwidth": 1,
            "type": "date"
          },
          "yaxis": {
            "automargin": true,
            "autorange": false,
            "gridcolor": "rgba(0, 0, 0, 0.15)",
            "range": [
              -0.1,
              1
            ],
            "rangemode": "tozero",
            "tickfont": {
              "size": 14
            },
            "title": {
              "font": {
                "size": 16
              },
              "standoff": 20,
              "text": "Precipitation (mm)"
            },
            "type": "linear"
          }
        },
        "onclick": "// Event handling\n/*\n// 'data', 'variables', 'options', 'utils', and 'event' are passed as arguments\n\ntry {\n  const { type: eventType, data: eventData } = event;\n  const { timeZone, dayjs, locationService, getTemplateSrv } = utils;\n\n  switch (eventType) {\n    case 'click':\n      console.log('Click event:', eventData.points);\n      break;\n    case 'select':\n      console.log('Selection event:', eventData.range);\n      break;\n    case 'zoom':\n      console.log('Zoom event:', eventData);\n      break;\n    default:\n      console.log('Unhandled event type:', eventType, eventData);\n  }\n\n  console.log('Current time zone:', timeZone);\n  console.log('From time:', dayjs(variables.__from).format());\n  console.log('To time:', dayjs(variables.__to).format());\n\n  // Example of using locationService\n  // locationService.partial({ 'var-example': 'test' }, true);\n\n} catch (error) {\n  console.error('Error in onclick handler:', error);\n}\n*/\n  ",
        "resScale": 2,
        "script": "// Helper functions\nfunction hasValues(field) {\n    return field && field.values && field.values.length > 0;\n}\n\nfunction getValues(field) {\n    return field.values || field.values.buffer;\n}\n\n// Add viridis color mapping function\nfunction getViridisColor(value, min, max) {\n    const viridisColors = [\n        '#440154', '#443982', '#31688e', '#21918c', '#35b779', '#90d743', '#fde725'\n    ];\n    const normalizedValue = (value - min) / (max - min);\n    const index = Math.floor(normalizedValue * (viridisColors.length - 1));\n    return viridisColors[Math.min(viridisColors.length - 1, Math.max(0, index))];\n}\n\n\n// Get panel variables\nconst year = Number(variables.verify_year.current.value);\nconst yearStart = new Date(year, 0, 1).getTime();\nconst yearEnd = new Date(year, 11, 31).getTime();\n\nlet series1 = data.series[0];  // Probability forecasts\nlet series2 = data.series[1];  // Truth onsets\nlet series3 = data.series[2];  // Onset dates by lead\n\nlet shapes_fcst = [];\n\n\n// Viridis color map\nconst viridisColors = [\n    '#440154', '#481567', '#482677', '#453781', '#404788', '#39568C', '#33638D',\n    '#2D708E', '#287D8E', '#238A8D', '#1F968B', '#20A387', '#29AF7F', '#3CBB75',\n    '#55C667', '#73D055', '#95D840', '#B8DE29', '#DCE319', '#FDE725'\n];\n\nlet traces = [];\nlet shapes = [];\n\n// Get unique leads from probability series\nconst uniqueLeads = [...new Set(getValues(series1.fields[1]))].sort((a, b) => a - b);\n\n// Create traces for each lead time\nuniqueLeads.forEach((leadTime, index) => {\n    const colorIndex = Math.floor((index / (uniqueLeads.length - 1)) * (viridisColors.length - 1));\n    const leadTimeDays = Math.round(leadTime / 86400 / 1_000_000_000); // Convert seconds to days\n    const color = viridisColors[colorIndex];\n\n    // Add probability line trace\n    const points = getValues(series1.fields[0]).map((t, i) => ({\n        time: t,\n        prob: series1.fields[2].values[i],\n        lead: series1.fields[1].values[i]\n    })).filter(p => p.lead === leadTime);\n\n    // Sort by time\n    points.sort((a, b) => a.time - b.time);\n\n    traces.push({\n        x: points.map(p => p.time),\n        y: points.map(p => p.prob),\n        type: 'scatter',\n        mode: 'lines',\n        name: `Lead: ${leadTimeDays} days`,\n        line: { color }\n    });\n\n    // Add x markers for onset dates from series3\n    if (hasValues(series3.fields[0])) {\n  \n        const leadValues = getValues(series3.fields[1]).map(lead => lead / 86400 / 1_000_000_000);  // Convert seconds to days\n        const onsetDates = getValues(series3.fields[2]);  // forecast onset dates\n        const uniqueLeads = [...new Set(leadValues)].sort((a, b) => a - b);\n        \n        uniqueLeads.forEach(lead => {\n            const leadIndices = leadValues.map((v, i) => v === lead ? i : -1).filter(i => i !== -1);\n            const leadTimes = leadIndices.map(i => onsetDates[i]);  // Use onset dates instead of issue times\n            const color = getViridisColor(lead, Math.min(...uniqueLeads), Math.max(...uniqueLeads));\n\n            traces.push({\n                x: leadTimes,\n                y: Array(leadTimes.length).fill(0),\n                type: 'scatter',\n                mode: 'markers',\n                showlegend: false,\n                name: `Forecast Lead ${lead.toFixed(0)} days`,\n                marker: {\n                    symbol: 'x',\n                    color: color,\n                    size: 10\n                }\n            });\n            \n            shapes_fcst =  shapes_fcst.concat(\n                leadTimes.map(time => ({\n                    type: 'line',\n                    x0: time,\n                    x1: time,\n                    y0: 0,\n                    y1: 1,\n                    xref: 'x',\n                    yref: 'paper',\n                    line: {\n                        color: color,\n                        width: 1,\n                        dash: 'solid'\n                    }\n                }))\n            );\n        });\n    }\n});\n\n// Add truth onsets if they exist\nif (hasValues(series2?.fields[0])) {\n    // Add onset markers\n    traces.push({\n        x: getValues(series2.fields[0]),\n        y: Array(series2.fields[0].values.length).fill(0),\n        type: 'scatter',\n        mode: 'markers',\n        name: `${year} Onsets`,\n        marker: {\n            color: 'red',\n            symbol: 'x',\n            size: 10\n        }\n    });\n\n    // Create vertical lines for truth onsets\n    shapes = shapes.concat(\n        getValues(series2.fields[0]).map(timestamp => ({\n            type: 'line',\n            x0: timestamp,\n            x1: timestamp,\n            y0: 0,\n            y1: 1,\n            xref: 'x',\n            yref: 'paper',\n            line: {\n                color: 'red',\n                width: 1,\n                dash: 'solid'\n            }\n        }))\n    );\n}\n\nreturn {\n    data: traces,\n    layout: {\n        shapes: [...shapes_fcst, ...shapes],        \n        xaxis: {\n            range: [yearStart, yearEnd],\n            type: 'date',\n            title: 'Time'\n        },\n        yaxis: {\n            range: [0, 1],\n            title: 'Probability'\n        }\n    }\n};",
        "syncTimeRange": false,
        "timeCol": ""
      },
      "pluginVersion": "1.8.1",
      "targets": [
        {
          "datasource": {
            "type": "grafana-postgresql-datasource",
            "uid": "bdz3m3xs99p1cf"
          },
          "editorMode": "code",
          "format": "table",
          "hide": false,
          "rawQuery": true,
          "rawSql": "SELECT time, lead_time, rainy_onset\nFROM \"$fcst_onset_prob_tab_name\"\nWHERE lat = ${lat} \n  AND lon = ${lon}\n  AND EXTRACT(YEAR FROM \"time\") IN (${verify_year})\nORDER BY \"time\", \"lead_time\";\n-- SELECT time, lead_time, rainy_forecast\n-- FROM \"$fcst_onset_prob_tab_name\"\n-- WHERE lat = ${lat} \n--   AND lon = ${lon}\n--   AND EXTRACT(YEAR FROM \"time\") IN (${verify_year})\n--   -- AND lead_time < 3110400000000000\n-- ORDER BY \"time\", \"lead_time\";",
          "refId": "A",
          "sql": {
            "columns": [
              {
                "parameters": [],
                "type": "function"
              }
            ],
            "groupBy": [
              {
                "property": {
                  "type": "string"
                },
                "type": "groupBy"
              }
            ],
            "limit": 50
          }
        },
        {
          "datasource": {
            "type": "grafana-postgresql-datasource",
            "uid": "bdz3m3xs99p1cf"
          },
          "editorMode": "code",
          "format": "table",
          "hide": false,
          "rawQuery": true,
          "rawSql": "SELECT \"rainy_onset\"\nFROM \"$onset_tab_name\"\nWHERE lat = ${lat} \n  AND lon = ${lon}\n  AND EXTRACT(YEAR FROM \"time\") IN (${verify_year})\nORDER BY \"rainy_onset\";",
          "refId": "B",
          "sql": {
            "columns": [
              {
                "parameters": [],
                "type": "function"
              }
            ],
            "groupBy": [
              {
                "property": {
                  "type": "string"
                },
                "type": "groupBy"
              }
            ],
            "limit": 50
          }
        },
        {
          "datasource": {
            "type": "grafana-postgresql-datasource",
            "uid": "bdz3m3xs99p1cf"
          },
          "editorMode": "code",
          "format": "table",
          "hide": false,
          "rawQuery": true,
          "rawSql": "SELECT time, lead_time, rainy_onset\nFROM \"$fcst_onset_tab_name\"\nWHERE lat = ${lat} \n  AND lon = ${lon}\n  AND EXTRACT(YEAR FROM \"time\") IN (${verify_year})\nORDER BY \"time\", \"lead_time\";",
          "refId": "C",
          "sql": {
            "columns": [
              {
                "parameters": [],
                "type": "function"
              }
            ],
            "groupBy": [
              {
                "property": {
                  "type": "string"
                },
                "type": "groupBy"
              }
            ],
            "limit": 50
          }
        },
        {
          "datasource": {
            "type": "grafana-postgresql-datasource",
            "uid": "bdz3m3xs99p1cf"
          },
          "editorMode": "code",
          "format": "table",
          "hide": false,
          "rawQuery": true,
          "rawSql": "-- dummy query to ensure that plot refreshes when the variable changes\nSELECT $group_by_lead_time",
          "refId": "D",
          "sql": {
            "columns": [
              {
                "parameters": [],
                "type": "function"
              }
            ],
            "groupBy": [
              {
                "property": {
                  "type": "string"
                },
                "type": "groupBy"
              }
            ],
            "limit": 50
          }
        }
      ],
      "title": "Daily Rainfall (mm)",
      "transparent": true,
      "type": "nline-plotlyjs-panel"
    }
  ],
  "preload": false,
  "refresh": "",
  "schemaVersion": 40,
  "tags": [],
  "templating": {
    "list": [
      {
        "current": {
          "text": "salient",
          "value": "salient"
        },
        "hide": 2,
        "includeAll": false,
        "label": "Forecast",
        "name": "forecast_hold",
        "options": [
          {
            "selected": true,
            "text": "Salient",
            "value": "salient"
          },
          {
            "selected": false,
            "text": "ECMWF IFS ER",
            "value": "ecmwf_ifs_er"
          },
          {
            "selected": false,
            "text": "ECMWF IFS ER Debiased",
            "value": "ecmwf_ifs_er_debiased"
          },
          {
            "selected": false,
            "text": "Clim 1985-2014",
            "value": "climatology_2015"
          },
          {
            "selected": false,
            "text": "Clim + Trend",
            "value": "climatology_trend_2015"
          },
          {
            "selected": false,
            "text": "Clim Rolling",
            "value": "climatology_rolling"
          }
        ],
        "query": "Salient : salient, ECMWF IFS ER : ecmwf_ifs_er, ECMWF IFS ER Debiased : ecmwf_ifs_er_debiased, Clim 1985-2014 : climatology_2015, Clim + Trend : climatology_trend_2015, Clim Rolling : climatology_rolling",
        "type": "custom"
      },
      {
        "current": {
          "text": "chirps",
          "value": "chirps"
        },
        "includeAll": false,
        "label": "Ground Truth",
        "name": "truth",
        "options": [
          {
            "selected": false,
            "text": "ERA5",
            "value": "era5"
          },
          {
            "selected": false,
            "text": "IMERG",
            "value": "imerg"
          },
          {
            "selected": false,
            "text": "GHCN",
            "value": "ghcn"
          },
          {
            "selected": true,
            "text": "CHIRPS",
            "value": "chirps"
          },
          {
            "selected": false,
            "text": "TAHMO",
            "value": "tahmo"
          },
          {
            "selected": false,
            "text": "LTN",
            "value": "ltn"
          }
        ],
        "query": "ERA5 : era5, IMERG : imerg, GHCN : ghcn, CHIRPS : chirps, TAHMO : tahmo, LTN : ltn",
        "type": "custom"
      },
      {
        "current": {
          "text": "mae",
          "value": "mae"
        },
        "includeAll": false,
        "label": "Metric",
        "name": "metric",
        "options": [
          {
            "selected": true,
            "text": "MAE",
            "value": "mae"
          },
          {
            "selected": false,
            "text": "Bias",
            "value": "bias"
          },
          {
            "selected": false,
            "text": "RMSE",
            "value": "rmse"
          }
        ],
        "query": "MAE : mae, Bias : bias, RMSE : rmse",
        "type": "custom"
      },
      {
        "current": {
          "text": "True",
          "value": "True"
        },
        "includeAll": false,
        "label": "Compare?",
        "name": "compare",
        "options": [
          {
            "selected": true,
            "text": "True",
            "value": "True"
          },
          {
            "selected": false,
            "text": "False",
            "value": "False"
          }
        ],
        "query": "True,False",
        "type": "custom"
      },
      {
        "current": {
          "text": "era5",
          "value": "era5"
        },
        "includeAll": false,
        "label": "Compare with",
        "name": "truth2",
        "options": [
          {
            "selected": true,
            "text": "ERA5",
            "value": "era5"
          },
          {
            "selected": false,
            "text": "IMERG",
            "value": "imerg"
          },
          {
            "selected": false,
            "text": "GHCN",
            "value": "ghcn"
          },
          {
            "selected": false,
            "text": "CHIRPS",
            "value": "chirps"
          },
          {
            "selected": false,
            "text": "TAHMO",
            "value": "tahmo"
          },
          {
            "selected": false,
            "text": "LTN",
            "value": "ltn"
          }
        ],
        "query": "ERA5 : era5, IMERG : imerg, GHCN : ghcn, CHIRPS : chirps, TAHMO : tahmo, LTN : ltn",
        "type": "custom"
      },
      {
        "current": {
          "text": "global1_5",
          "value": "global1_5"
        },
        "hide": 2,
        "includeAll": false,
        "label": "Grid",
        "name": "grid",
        "options": [
          {
            "selected": true,
            "text": "1.5",
            "value": "global1_5"
          }
        ],
        "query": "1.5 : global1_5",
        "type": "custom"
      },
      {
        "current": {
          "text": "kenya",
          "value": "kenya"
        },
        "hide": 2,
        "includeAll": false,
        "label": "Region",
        "name": "region",
        "options": [
          {
            "selected": true,
            "text": "Kenya",
            "value": "kenya"
          }
        ],
        "query": "Kenya : kenya",
        "type": "custom"
      },
      {
        "current": {
          "text": "",
          "value": ""
        },
        "datasource": {
          "type": "grafana-postgresql-datasource",
          "uid": "bdz3m3xs99p1cf"
        },
        "definition": "SELECT DISTINCT (\"time\" AT TIME ZONE 'UTC')::date::text as formatted_time\nFROM \"$rainfall_tab_name\"\nWHERE time IS NOT NULL\n  AND $__timeFilter(time)\nORDER BY formatted_time",
        "hide": 2,
        "includeAll": false,
        "label": "Lead",
        "name": "leads",
        "options": [],
        "query": "SELECT DISTINCT (\"time\" AT TIME ZONE 'UTC')::date::text as formatted_time\nFROM \"$rainfall_tab_name\"\nWHERE time IS NOT NULL\n  AND $__timeFilter(time)\nORDER BY formatted_time",
        "refresh": 1,
        "regex": "",
        "type": "query"
      },
      {
        "current": {
          "text": "-1.50",
          "value": "-1.50"
        },
        "hide": 2,
        "includeAll": false,
        "label": "Latitude",
        "name": "lat",
        "options": [
          {
            "selected": true,
            "text": "-1.50",
            "value": "-1.50"
          }
        ],
        "query": "-1.50",
        "type": "custom"
      },
      {
        "current": {
          "text": "37.50",
          "value": "37.50"
        },
        "hide": 2,
        "includeAll": false,
        "label": "Longitude",
        "name": "lon",
        "options": [
          {
            "selected": true,
            "text": "37.50",
            "value": "37.50"
          }
        ],
        "query": "37.50",
        "type": "custom"
      },
      {
        "current": {
          "text": "f027cd1b4aecf0bb455440e1b312f399",
          "value": "f027cd1b4aecf0bb455440e1b312f399"
        },
        "datasource": {
          "type": "grafana-postgresql-datasource",
          "uid": "bdz3m3xs99p1cf"
        },
        "definition": "select * from md5('rain_windowed_spw/${grid}_lsm_kenya_${truth}')",
        "hide": 2,
        "includeAll": false,
        "name": "rainfall_tab_name",
        "options": [],
        "query": "select * from md5('rain_windowed_spw/${grid}_lsm_kenya_${truth}')",
        "refresh": 2,
        "regex": "",
        "type": "query"
      },
      {
        "current": {
          "text": "3ab5965d0a510533886347865bececda",
          "value": "3ab5965d0a510533886347865bececda"
        },
        "datasource": {
          "type": "grafana-postgresql-datasource",
          "uid": "bdz3m3xs99p1cf"
        },
        "definition": "select * from md5('summary_metrics_table/2022-12-31_${grid}_lsm_${metric}_${region}_2016-01-01_None_era5_${task}')",
        "hide": 2,
        "includeAll": false,
        "name": "metrics_tab_name",
        "options": [],
        "query": "select * from md5('summary_metrics_table/2022-12-31_${grid}_lsm_${metric}_${region}_2016-01-01_None_era5_${task}')",
        "refresh": 2,
        "regex": "",
        "type": "query"
      },
      {
        "current": {
          "text": "5362bdc9d0bbbeb7a94ea5b92de4657e",
          "value": "5362bdc9d0bbbeb7a94ea5b92de4657e"
        },
        "datasource": {
          "type": "grafana-postgresql-datasource",
          "uid": "bdz3m3xs99p1cf"
        },
        "definition": "select * from md5('rain_windowed_spw/${grid}_lsm_kenya_${truth2}')",
        "hide": 2,
        "includeAll": false,
        "name": "rainfall2_tab_name",
        "options": [],
        "query": "select * from md5('rain_windowed_spw/${grid}_lsm_kenya_${truth2}')",
        "refresh": 2,
        "regex": "",
        "type": "query"
      },
      {
        "current": {
          "text": [
            "2023"
          ],
          "value": [
            "2023"
          ]
        },
        "hide": 2,
        "includeAll": true,
        "label": "Years",
        "multi": true,
        "name": "years",
        "options": [
          {
            "selected": false,
            "text": "2015",
            "value": "2015"
          },
          {
            "selected": false,
            "text": "2016",
            "value": "2016"
          },
          {
            "selected": false,
            "text": "2017",
            "value": "2017"
          },
          {
            "selected": false,
            "text": "2018",
            "value": "2018"
          },
          {
            "selected": false,
            "text": "2019",
            "value": "2019"
          },
          {
            "selected": false,
            "text": "2020",
            "value": "2020"
          },
          {
            "selected": false,
            "text": "2021",
            "value": "2021"
          },
          {
            "selected": false,
            "text": "2022",
            "value": "2022"
          },
          {
            "selected": true,
            "text": "2023",
            "value": "2023"
          }
        ],
        "query": "2015, 2016, 2017, 2018, 2019, 2020, 2021, 2022, 2023",
        "type": "custom"
      },
      {
        "current": {
          "text": "3ea1e16a758f0d4f2d554c39fbfbb067",
          "value": "3ea1e16a758f0d4f2d554c39fbfbb067"
        },
        "datasource": {
          "type": "grafana-postgresql-datasource",
          "uid": "bdz3m3xs99p1cf"
        },
        "definition": "select * from md5('ea_rainy_onset_truth/global1_5_lsm_kenya_${truth}_${ltn}')\n",
        "hide": 2,
        "includeAll": false,
        "name": "onset_tab_name",
        "options": [],
        "query": "select * from md5('ea_rainy_onset_truth/global1_5_lsm_kenya_${truth}_${ltn}')\n",
        "refresh": 2,
        "regex": "",
        "type": "query"
      },
      {
        "current": {
          "text": "65f7accc5e005991b411ff2ffe78babb",
          "value": "65f7accc5e005991b411ff2ffe78babb"
        },
        "datasource": {
          "type": "grafana-postgresql-datasource",
          "uid": "bdz3m3xs99p1cf"
        },
        "definition": "select * from md5('ea_rainy_onset_forecast/${forecast}_global1_5_lsm_kenya_False')\n\n\n",
        "hide": 2,
        "includeAll": false,
        "name": "fcst_onset_tab_name",
        "options": [],
        "query": "select * from md5('ea_rainy_onset_forecast/${forecast}_global1_5_lsm_kenya_False')\n\n\n",
        "refresh": 2,
        "regex": "",
        "type": "query"
      },
      {
        "current": {
          "text": "a20b79dba2cbb8aa34a0fd005c5e19a5",
          "value": "a20b79dba2cbb8aa34a0fd005c5e19a5"
        },
        "datasource": {
          "type": "grafana-postgresql-datasource",
          "uid": "bdz3m3xs99p1cf"
        },
        "definition": "select * from md5('ea_rainy_onset_probabilities/${forecast}_global1_5_lsm_kenya_False')\n\n",
        "hide": 2,
        "includeAll": false,
        "name": "fcst_onset_prob_tab_name",
        "options": [],
        "query": "select * from md5('ea_rainy_onset_probabilities/${forecast}_global1_5_lsm_kenya_False')\n\n",
        "refresh": 2,
        "regex": "",
        "type": "query"
      },
      {
        "current": {
          "text": "2018",
          "value": "2018"
        },
        "includeAll": false,
        "label": "Verify Year",
        "name": "verify_year",
        "options": [
          {
            "selected": false,
            "text": "2016",
            "value": "2016"
          },
          {
            "selected": false,
            "text": "2017",
            "value": "2017"
          },
          {
            "selected": true,
            "text": "2018",
            "value": "2018"
          },
          {
            "selected": false,
            "text": "2019",
            "value": "2019"
          },
          {
            "selected": false,
            "text": "2020",
            "value": "2020"
          },
          {
            "selected": false,
            "text": "2021",
            "value": "2021"
          },
          {
            "selected": false,
            "text": "2022",
            "value": "2022"
          }
        ],
        "query": "2016, 2017, 2018, 2019, 2020, 2021, 2022",
        "type": "custom"
      },
      {
        "current": {
          "text": "441466513e66a50d0b1f8c87c63f734b",
          "value": "441466513e66a50d0b1f8c87c63f734b"
        },
        "datasource": {
          "type": "grafana-postgresql-datasource",
          "uid": "bdz3m3xs99p1cf"
        },
        "definition": "select * from md5('rainy_onset_spw_forecast/2022-12-31_${forecast}_global1_5_lsm_kenya_2016-01-01')",
        "hide": 2,
        "includeAll": false,
        "name": "onset_fcst_tab_name",
        "options": [],
        "query": "select * from md5('rainy_onset_spw_forecast/2022-12-31_${forecast}_global1_5_lsm_kenya_2016-01-01')",
        "refresh": 2,
        "regex": "",
        "type": "query"
      },
      {
        "current": {
          "text": "ecmwf_ifs_er",
          "value": "ecmwf_ifs_er"
        },
        "includeAll": false,
        "label": "Forecast",
        "name": "forecast",
        "options": [
          {
            "selected": true,
            "text": "ECMWF IFS ER",
            "value": "ecmwf_ifs_er"
          },
          {
            "selected": false,
            "text": "ECMWF IFS ER Debiased",
            "value": "ecmwf_ifs_er_debiased"
          },
          {
            "selected": false,
            "text": "LTN",
            "value": "climatology_2015"
          },
          {
            "selected": false,
            "text": "FuXi",
            "value": "fuxi"
          }
        ],
        "query": "ECMWF IFS ER : ecmwf_ifs_er, ECMWF IFS ER Debiased : ecmwf_ifs_er_debiased, LTN : climatology_2015, FuXi : fuxi",
        "type": "custom"
      },
      {
        "current": {
          "text": "ecmwf_ifs_er_debiased",
          "value": "ecmwf_ifs_er_debiased"
        },
        "includeAll": false,
        "label": "Baseline",
        "name": "baseline",
        "options": [
          {
            "selected": false,
            "text": "ECMWF IFS ER",
            "value": "ecmwf_ifs_er"
          },
          {
            "selected": true,
            "text": "ECMWF IFS ER Debiased",
            "value": "ecmwf_ifs_er_debiased"
          },
          {
            "selected": false,
            "text": "LTN",
            "value": "climatology_2015"
          },
          {
            "selected": false,
            "text": "FuXi",
            "value": "fuxi"
          }
        ],
        "query": "ECMWF IFS ER : ecmwf_ifs_er, ECMWF IFS ER Debiased : ecmwf_ifs_er_debiased, LTN : climatology_2015, FuXi : fuxi",
        "type": "custom"
      },
      {
        "current": {
          "text": "True",
          "value": "True"
        },
        "hide": 2,
        "includeAll": false,
        "label": "Lead or Forecast Date?",
        "name": "group_by_lead_time",
        "options": [
          {
            "selected": true,
            "text": "True",
            "value": "True"
          },
          {
            "selected": false,
            "text": "False",
            "value": "False"
          }
        ],
        "query": "True,False",
        "type": "custom"
      },
      {
        "current": {
          "text": "fe86855b7b0437b7665a39a8fbd4eea9",
          "value": "fe86855b7b0437b7665a39a8fbd4eea9"
        },
        "datasource": {
          "type": "grafana-postgresql-datasource",
          "uid": "bdz3m3xs99p1cf"
        },
        "definition": "select * from md5('ea_rainy_onset_truth/${grid}_lsm_kenya_ltn')",
        "hide": 2,
        "includeAll": false,
        "name": "ltn_onset_tab_name",
        "options": [],
        "query": "select * from md5('ea_rainy_onset_truth/${grid}_lsm_kenya_ltn')",
        "refresh": 2,
        "regex": "",
        "type": "query"
      },
      {
        "current": {
          "text": "eb3899ee9503da754540ebcafb578404",
          "value": "eb3899ee9503da754540ebcafb578404"
        },
        "datasource": {
          "type": "grafana-postgresql-datasource",
          "uid": "bdz3m3xs99p1cf"
        },
        "definition": "select * from md5('rain_windowed_spw/${grid}_lsm_kenya_ltn')",
        "hide": 2,
        "includeAll": false,
        "name": "ltn_precip_tab_name",
        "options": [],
        "query": "select * from md5('rain_windowed_spw/${grid}_lsm_kenya_ltn')",
        "refresh": 2,
        "regex": "",
        "type": "query"
      },
      {
        "current": {
          "text": "False",
          "value": "False"
        },
        "hide": 2,
        "includeAll": false,
        "label": "Use LTN?",
        "name": "ltn",
        "options": [
          {
            "selected": true,
            "text": "False",
            "value": "False"
          },
          {
            "selected": false,
            "text": "True",
            "value": "True"
          }
        ],
        "query": "False,True",
        "type": "custom"
      },
      {
        "current": {
          "text": "rainy_onset_no_drought",
          "value": "rainy_onset_no_drought"
        },
        "includeAll": false,
        "label": "Task",
        "name": "task",
        "options": [
          {
            "selected": false,
            "text": "Rainy Onset",
            "value": "rainy_onset"
          },
          {
            "selected": true,
            "text": "Rainy Onset w/o Drought",
            "value": "rainy_onset_no_drought"
          }
        ],
        "query": "Rainy Onset : rainy_onset,Rainy Onset w/o Drought : rainy_onset_no_drought",
        "type": "custom"
      }
    ]
  },
  "time": {
    "from": "now-6h",
    "to": "now"
  },
  "timepicker": {},
  "timezone": "utc",
  "title": "Suitable Planting Window Graphs",
  "uid": "becpaz5nsxr7kc",
  "version": 11,
  "weekStart": ""
}

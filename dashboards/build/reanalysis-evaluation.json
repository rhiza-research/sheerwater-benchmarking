{
  "annotations": {
    "list": [
      {
        "builtIn": 1,
        "datasource": {
          "type": "grafana",
          "uid": "-- Grafana --"
        },
        "enable": true,
        "hide": true,
        "iconColor": "rgba(0, 211, 255, 1)",
        "name": "Annotations & Alerts",
        "type": "dashboard"
      }
    ]
  },
  "editable": true,
  "fiscalYearStartMonth": 0,
  "graphTooltip": 0,
  "id": 16,
  "links": [],
  "panels": [
    {
      "datasource": {
        "uid": "bdz3m3xs99p1cf"
      },
      "fieldConfig": {
        "defaults": {
          "thresholds": {
            "mode": "absolute",
            "steps": [
              {
                "color": "green",
                "value": null
              },
              {
                "color": "red",
                "value": 80
              }
            ]
          }
        },
        "overrides": []
      },
      "gridPos": {
        "h": 6,
        "w": 24,
        "x": 0,
        "y": 0
      },
      "id": 7,
      "options": {
        "afterRender": "// window.onload = function () {\n//     renderMathInElement(document.body, {\n//         delimiters: [\n//             { left: \"$$\", right: \"$$\", display: true },\n//             { left: \"\\\\(\", right: \"\\\\)\", display: false }\n//         ]\n//     });\n// };\n",
        "content": "### Selected Metric: {{#if (eq metric \"mae\")}}MAE {{/if}} {{#if (eq metric \"rmse\")}}RMSE{{/if}} {{#if (eq metric \"pearson\")}}Pearson Correlation{{/if}} {{#if (eq metric \"crps\")}}CRPS{{/if}} {{#if (eq metric \"bias\")}}Bias{{/if}} {{#if (eq metric \"smape\")}}SMAPE{{/if}} {{#if (eq metric \"seeps\")}}SEEPS{{/if}} {{#if (eq metric \"acc\")}}ACC{{/if}}  {{#if (eq metric \"heidke-1-5-10-20\")}}Heidke 1/5/10/20mm{{/if}} {{#if (eq metric \"far-1\")}}FAR 1mm{{/if}} {{#if (eq metric \"far-5\")}}FAR 5mm{{/if}} {{#if (eq metric \"far-10\")}}FAR 10mm{{/if}} {{#if (eq metric \"pod-1\")}}POD 1mm{{/if}} {{#if (eq metric \"pod-5\")}}POD 5mm{{/if}} {{#if (eq metric \"pod-10\")}}POD 10mm{{/if}} {{#if (eq metric \"ets-1\")}}ETS 1mm{{/if}} {{#if (eq metric \"ets-5\")}}ETS 5mm{{/if}} {{#if (eq metric \"ets-10\")}}ETS 10mm{{/if}}\n\n{{#if (eq metric \"mae\")}}\nMean absolute error (MAE) measures the average magnitude of the errors in a set of predictions, without considering\ntheir direction.\\\n<span style=\"color: red; font-weight: bold;\">ðŸ”´ Smaller is better â€” lower MAE means better predictions.</span> \n\n{{else if (eq metric \"crps\")}}\nContinuous ranked probability score (CRPS) assesses the accuracy of probabilistic forecasts by comparing the cumulative\ndistribution function of forecasts to the observed values.\\\n<span style=\"color: red; font-weight: bold;\">ðŸ”´ Smaller is better â€” lower CRPS indicates better probabilistic forecasting skill.</span>\n\n{{else if (eq metric \"rmse\")}}\nRoot mean squared error (RMSE) gives higher weight to large errors, making it more sensitive to outliers.\\\n<span style=\"color: red; font-weight: bold;\">ðŸ”´ Smaller is better â€” lower RMSE means better predictions.</span>\n\n{{else if (eq metric \"acc\")}}\nAnomaly correlation coefficient (ACC) ACC is a measure of how well the forecast anomalies have represented the observed anomalies\nrelative to climatology. We used 1991-2020 climatology (years inclusive) for our ACC calculation.\\\n<span style=\"color: green; font-weight: bold;\">ðŸŸ¢ Larger is better â€” higher ACC means better predictions. Range [-1, 1].</span>\n\n{{else if (eq metric \"pearson\")}}\nPearson correlation measures the linear correlation between two datasets. \\\n<span style=\"color: green; font-weight: bold;\">ðŸŸ¢ Larger is better â€” higher pearson means better correlation. Range [-1, 1].</span>\n\n{{else if (eq metric \"bias\")}}\nBias measures the signed magnitude of errors in a set of predictions. \\\n<span style=\"color: gray; font-weight: bold;\">âšª Ideal value = 0.0 â€” Bias should be close to 0.0 for an unbiased forecast.</span>\n\n{{else if (eq metric \"smape\")}}\nSymmetric mean absolute percentage error (SMAPE) is a normalized version of Mean Absolute Percentage Error (MAPE) and calculate sthe error as a percentage of the total value. We only calculate SMAPE for precipitation.\\\n<span style=\"color: red; font-weight: bold;\">ðŸ”´ Smaller is better â€” lower SMAPE indicates better forecasting accuracy. Range [0, 1].</span>\n\n{{else if (eq metric \"seeps\")}}\nStable equitable error in probability space (SEEPS) is a score designed for evaluating rainfall forecasts while taking into account climactic difference in rainfall. Areas that are too dry or wet are exclued. \nWe include all cells with a 3-93% non-dry day frequency to ensure inclusion of relevant parts of Africa. We only calculate SEEPS for precipitation.\\\n<span style=\"color: red; font-weight: bold;\">ðŸ”´ Smaller is better â€” lower SEEPS indicates better forecasting accuracy. Good SEEPS for short term forecasts on cells that have 10-85% non-dry days are considered between 0-1.</span>\n\n{{else if (eq metric \"heidke-1-5-10-20\")}}\nHeidke skill score (HSS) compares the accuracy of a forecast to random chance for a set of predetermined rainfall thresholdsâ€”in this case, 1, 5, 10, and 20mm. We only calculate Heidke for precipitation.\\\n<span style=\"color: green; font-weight: bold;\">ðŸŸ¢ Larger is better â€” a higher HSS indicates better skill. Range [-&infin;, 1]</span>\n\n{{else if (or (eq metric \"pod-1\") (or (eq metric \"pod-5\") (eq metric \"pod-10\")))}}\nProbability of detection (POD) measures the fraction of observed rainfall events that were correctly predictedâ€”in this case, a weekly average daily rainfall of over 1, 5, or 10mm. We only calculate POD for precipitation. \\\n<span style=\"color: green; font-weight: bold;\">ðŸŸ¢ Larger is better â€” higher probability of detection is better. Range [0, 1]. </span>\n\n{{else if (or (eq metric \"far-1\") (or (eq metric \"far-5\") (eq metric \"far-10\")))}}\nFalse alarm rate (FAR) quantifies the fraction of predicted rainfall events that were not observedâ€”in this case, a weekly average daily rainfall of over 1, 5, or 10mm. We only calculate FAR for precipitation.\\ \n<span style=\"color: red; font-weight: bold;\">ðŸ”´ Smaller is better â€” lower false alarm rate is better. Range [0, 1].</span>\n\n{{else if (or (eq metric \"ets-1\") (or (eq metric \"ets-5\") (eq metric \"ets-10\")))}}\nEquitable threat score (ETS) measures a combination of POD and FAR while accounting for random chance on a specific eventâ€”in this case, a weekly average daily rainfall of over 1, 5, or 10mm. We only calculate ETS for precipitation. \\\n<span style=\"color: green; font-weight: bold;\">ðŸŸ¢ Larger is better â€” higher ETS indicates better skill. Range [-1/3, 1].</span>\n\n{{else}}\n_no description available for this metric._\n{{/if}}\n\n#### In Africa most grid cells do not have GHCN coverage\n**0.25 grid**: Global: 3.7% (14551/395603)&emsp;CONUS: 55.6% (7284/13090)&emsp;Africa: 0.1% (42/40903)\\\n**1.5 grid**:&emsp;Global: 10.9% (2418/22116)&emsp;&emsp;CONUS: 50% (360/720)&emsp;&emsp;&nbsp;&nbsp;&emsp;Africa: 1.5% (33/2248)\\\n*Coverage defined as >50% of days with valid precip data*",
        "contentPartials": [],
        "defaultContent": "The query didn't return any results.",
        "editor": {
          "format": "auto",
          "language": "markdown"
        },
        "editors": [],
        "externalStyles": [],
        "helpers": "",
        "renderMode": "everyRow",
        "styles": "",
        "wrap": true
      },
      "pluginVersion": "5.6.0",
      "targets": [
        {
          "editorMode": "code",
          "format": "table",
          "rawQuery": true,
          "rawSql": "select '${metric}' as metric\n",
          "refId": "A",
          "sql": {
            "columns": [
              {
                "parameters": [],
                "type": "function"
              }
            ],
            "groupBy": [
              {
                "property": {
                  "type": "string"
                },
                "type": "groupBy"
              }
            ],
            "limit": 50
          }
        }
      ],
      "title": "",
      "transparent": true,
      "type": "marcusolsson-dynamictext-panel"
    },
    {
      "collapsed": true,
      "gridPos": {
        "h": 1,
        "w": 24,
        "x": 0,
        "y": 6
      },
      "id": 8,
      "panels": [
        {
          "datasource": {
            "uid": "bdz3m3xs99p1cf"
          },
          "fieldConfig": {
            "defaults": {
              "thresholds": {
                "mode": "absolute",
                "steps": [
                  {
                    "color": "green",
                    "value": null
                  },
                  {
                    "color": "red",
                    "value": 80
                  }
                ]
              }
            },
            "overrides": []
          },
          "gridPos": {
            "h": 10,
            "w": 24,
            "x": 0,
            "y": 7
          },
          "id": 10,
          "options": {
            "afterRender": "// window.onload = function () {\n//     renderMathInElement(document.body, {\n//         delimiters: [\n//             { left: \"$$\", right: \"$$\", display: true },\n//             { left: \"\\\\(\", right: \"\\\\)\", display: false }\n//         ]\n//     });\n// };\n",
            "content": " - All metrics are computed with the ECMWF land-sea mask that includes any cell with non-zero land coverage. \n - Spatial averages use latitude-based weighting.\n\n - Conservative regridding is used for both upscaling and downscaling data. \n \n - ERA5 is native 0.25 x 0.25. IMERG and CHIRPS are native 0.1x0.1. CBAM is native 4km (0.04 x 0.04).\n\n - CBAM is custom reanalaysis product that used WRF in combination with GHCN data to produce a higher\n resolution reanalysis.\n \n - To account for variability in station density there are two station sources - \"Random\" which selects one station\n in each grid cell for comparison, and \"Average\" which averages all stations in a grid cell. \n In CONUS many grid cells have more than one station, but this is rarely the case in Africa.\n\n - TAHMO data often experiences extreme values, which makes some of its metrics, especially RMSE unreliability. \n TAHMO metrics should be considered preliminary until further cleaning has been performed, but it is included\n because there is significantly more TAHMO data available.\n\n  - Metrics that cannot be globally computed and then reduced (such as ACC, POD, FAR, ETC) are not available with time groupings.",
            "contentPartials": [],
            "defaultContent": "The query didn't return any results.",
            "editor": {
              "format": "auto",
              "language": "markdown"
            },
            "editors": [],
            "externalStyles": [],
            "helpers": "",
            "renderMode": "everyRow",
            "styles": "",
            "wrap": true
          },
          "pluginVersion": "5.6.0",
          "targets": [
            {
              "editorMode": "code",
              "format": "table",
              "rawQuery": true,
              "rawSql": "select '${metric}' as metric\n",
              "refId": "A",
              "sql": {
                "columns": [
                  {
                    "parameters": [],
                    "type": "function"
                  }
                ],
                "groupBy": [
                  {
                    "property": {
                      "type": "string"
                    },
                    "type": "groupBy"
                  }
                ],
                "limit": 50
              }
            }
          ],
          "title": "",
          "transparent": true,
          "type": "marcusolsson-dynamictext-panel"
        }
      ],
      "title": "Notes & Caveats",
      "type": "row"
    },
    {
      "collapsed": false,
      "gridPos": {
        "h": 1,
        "w": 24,
        "x": 0,
        "y": 7
      },
      "id": 9,
      "panels": [],
      "title": "Metrics",
      "type": "row"
    },
    {
      "datasource": {
        "default": true,
        "type": "grafana-postgresql-datasource",
        "uid": "bdz3m3xs99p1cf"
      },
      "fieldConfig": {
        "defaults": {},
        "overrides": [
          {
            "matcher": {
              "id": "byName",
              "options": "forecast"
            },
            "properties": []
          },
          {
            "matcher": {
              "id": "byName",
              "options": "forecast"
            },
            "properties": []
          }
        ]
      },
      "gridPos": {
        "h": 8,
        "w": 12,
        "x": 0,
        "y": 8
      },
      "id": 3,
      "options": {
        "allData": {},
        "config": {},
        "data": [],
        "imgFormat": "png",
        "layout": {
          "font": {
            "family": "Inter, sans-serif"
          },
          "margin": {
            "b": 0,
            "l": 0,
            "r": 0,
            "t": 0
          },
          "paper_bgcolor": "#F4F5F5",
          "plog_bgcolor": "#F4F5F5",
          "title": {
            "align": "left",
            "automargin": true,
            "font": {
              "color": "black",
              "family": "Inter, sans-serif",
              "size": 14,
              "weight": 500
            },
            "pad": {
              "b": 30
            },
            "x": 0,
            "xanchor": "left"
          },
          "xaxis": {
            "automargin": true,
            "autorange": true,
            "type": "date"
          },
          "yaxis": {
            "automargin": true,
            "autorange": true
          }
        },
        "onclick": "",
        "resScale": 0,
        "script": "// Utility function to convert hex color to an RGB object\nfunction hexToRgb(hex) {\n    const bigint = parseInt(hex.slice(1), 16);\n    return {\n        r: (bigint >> 16) & 255,\n        g: (bigint >> 8) & 255,\n        b: bigint & 255\n    };\n}\n\n// Function to get interpolated color by passing a value from 0 to 1\nfunction getColor(value, cmin, cmax, colorMap) {\n    let colors;\n\n    // Define color scales based on the selected colormap\n    if (colorMap === 'BrBG') {\n        colors = [\n            \"#543005\",\n            \"#8C510A\", \"#BF812D\", \"#DFC27D\", \"#F6E8C3\",\n            \"#F5F5F5\", \"#C7EAE5\", \"#80CDC1\", \"#35978F\", \"#01665E\",\n            \"#003C30\"\n        ];\n    } else if (colorMap === 'balance') {\n        colors = [\n            \"#2a0a0a\",\n            \"#751b1b\", \"#b73c3c\", \"#e88484\", \"#f3c3c3\", // Negative side\n            \"#ffffff\",                                            // Neutral middle\n            \"#c3e4f3\", \"#84c2e8\", \"#3c9fb7\", \"#1b5e75\",  // Positive side\n            \"#0a2a2a\"\n        ];\n        colors = colors.reverse()\n    } else if (colorMap === 'RdBu') {\n        colors = ['#ff0000', '#ffffff', '#0000ff'];\n    } else if (colorMap === 'BuRd') {\n        colors = ['#0000ff', '#ffffff', '#ff0000'];        \n    } else {\n        throw new Error(\"Invalid colorMap. Choose 'BrBG', 'balance', or 'RdBu'.\");\n    }\n\n    let x;\n    if (value > 0) {\n        x = 0.5 + (value / cmax) * 0.5;  // Map positive values from 0.5 to 1.0\n    } else if (value < 0) {\n        x = 0.5 + (value / (-cmin)) * 0.5;  // Map negative values from 0.0 to 0.5\n    } else {\n        x = 0.5;  // Zero maps to middle\n    }    \n\n    // Clamp value between 0 and 1\n    x = Math.min(1, Math.max(0, x));\n    if (isNaN(x)) {\n        return `rgba(255, 255, 255, 0.5)`;\n    }\n\n    // Compute exact position in color array\n    const scaledValue = x * (colors.length - 1);\n    const lowerIndex = Math.floor(scaledValue);\n    const upperIndex = Math.ceil(scaledValue);\n\n    // Edge case: if at the end of the array, return the last color\n    if (lowerIndex === upperIndex) {\n        const color = hexToRgb(colors[lowerIndex]);\n        return `rgba(${color.r}, ${color.g}, ${color.b}, 0.5)`;\n    }\n\n    // Interpolate between the two colors\n    const lowerColor = hexToRgb(colors[lowerIndex]);\n    const upperColor = hexToRgb(colors[upperIndex]);\n    const t = scaledValue - lowerIndex;\n\n    // Interpolate RGB channels\n    const r = Math.round(lowerColor.r + t * (upperColor.r - lowerColor.r));\n    const g = Math.round(lowerColor.g + t * (upperColor.g - lowerColor.g));\n    const b = Math.round(lowerColor.b + t * (upperColor.b - lowerColor.b));\n\n    // Return the interpolated color as an rgb(r, g, b) string\n    return `rgba(${r}, ${g}, ${b}, 0.5)`;\n}\n\nlet series = data.series[0]\nif (series.length == 0) {\n    return {\n        data: []\n    }\n}\n\nif (variables.time_grouping.current.value != 'None') {\n    idx = 1\n} else {\n    idx = 0\n}\nforecasts = series.fields[1 + idx].values\nvalues = []\nskills = []\nheader = [\"Forecast\", \"Daily\", \"Weekly\", \"Biweekly\", \"Monthly\"]\norig_header = [\"forecast\", \"daily\", 'weekly', 'biweekly', 'monthly']\nlet max = -Infinity;\nlet min = Infinity;\n\nskill_baseline_idx = null;\nfor (var i = 0; i < forecasts.length; i = i + 1) {\n    if (variables.baseline.current.value == forecasts[i]) {\n        skill_baseline_idx = i\n    }\n}\n\nbaseline_values = []\nfor (var i = 2 + idx; i < series.fields.length; i = i + 1) {\n    baseline_values.push(series.fields[i].values[skill_baseline_idx])\n}\n\nfor (var i = 2 + idx; i < series.fields.length; i = i + 1) {\n    v = series.fields[i].values\n    skill_values = []\n    for (var j = 0; j < v.length; j++) {\n        let val = parseFloat(v[j]);\n        if (val > max) {\n            max = val;\n        }\n        if (val < min) {\n            min = val;\n        }     \n        if (isNaN(val) || baseline_values[(i - 2 - idx)] == null || isNaN(baseline_values[(i - 2 - idx)])) {\n            skill_values.push(NaN)\n        }      \n        else{\n            skill_values.push((1 - (val / baseline_values[(i - 2 - idx)])))\n        }\n    }\n    values.push(v)\n    skills.push(skill_values)\n}\n\nconsole.log(skills)\n\n// round to two decimal places\nvalues = values.map((week) => week.map((x) => { if (x) { return x.toFixed(2) } else { return '-' } }))\nforecasts = forecasts.map((forecast) => forecast.replaceAll('_', ' ').split(' ').map((word) => word[0].toUpperCase() + word.substring(1)).join(' '))\nvalues.unshift(forecasts)\n\n// Rename dictionary\nconst renameDict = {\n    \"Chirps\": \"CHIRPS\",\n    \"Era5\": \"ERA5\",\n    \"Imerg\": \"IMERG\",\n    \"Cbam\": \"CBAM\",\n};\n\n// Apply custom renaming to the first column of cellValues\nvalues[0] = values[0].map(value => renameDict[value] || value);\n\n// assign the forecast colors\nforecast_colors = []\nfor (var i = 0; i < forecasts.length; i++) {\n    forecast_colors.push('rgba(0,0,0,0)')\n}\n\nlet skill_colors = []\n// assign the skill colors\nlet colorMap, cmax, cmin;\n// if (variables['metric'].current.value == 'bias') {\n//     colormap = 'balance';\n//     cmax = max;\n//     cmin = min;\n// }\n// else {\n//     colormap = 'rdbu';\n//     cmax = 1;\n//     cmin = -1;\n// }\n// Determine color map and ranges based on metric\nswitch (variables['metric'].current.value) {\n    case 'bias':\n        colorMap = 'BuRd';\n        [cmin, cmax] = [min, max];\n        break;\n    case 'acc':\n        colorMap = 'RdBu';\n        [cmin, cmax] = [-1, 1];\n        break;\n    // Error metrics - smaller is better\n    case 'mae':\n    case 'crps':\n    case 'rmse':\n    case 'smape':\n    case 'seeps':\n        colorMap = 'RdBu';\n        [cmin, cmax] = [-1, 1];\n        break;\n    // Skill score metrics - larger is better\n    case 'heidke-1-5-10-20':\n    case 'pod-1':\n    case 'pod-5':\n    case 'pod-10':\n    case 'ets-1':\n    case 'ets-5':\n    case 'ets-10':\n        colorMap = 'RdBu';\n        [cmin, cmax] = [0, 1];\n        break;\n    // FAR metrics - smaller is better\n    case 'far-1':\n    case 'far-5':\n    case 'far-10':\n        colorMap = 'RdBu';\n        [cmin, cmax] = [0, 1];\n        break;\n    default:\n        colorMap = 'RdBu';\n        [cmax, cmin] = [1, -1];\n}\n\nfor (var i = 0; i < skills.length; i++) {\n    let week_colors = [];\n    for (var j = 0; j < skills[i].length; j++) {\n        if (variables['metric'].current.value == 'acc' || variables['metric'].current.value == 'bias') {\n            val = parseFloat(values[i + 1][j]);\n        } else {\n            val = parseFloat(skills[i][j]);\n        }\n        week_colors.push(getColor(val, cmin, cmax, colorMap))\n    }\n    skill_colors.push(week_colors)\n}\n\nlet metric = variables['metric'].current.value;\nvar units = \"\"\nif (metric == 'mae' || metric == 'bias' || metric == 'crps' || metric == 'rmse') {\n    units = \" (C)\"\n}\n\nvar region = variables['region'].current.value\n\nfunction cap(str) {\n  var i, frags = str.split('_');\n  for (i=0; i<frags.length; i++) {\n    frags[i] = frags[i].charAt(0).toUpperCase() + frags[i].slice(1);\n  }\n  return frags.join(' ');\n}\n\nregion = cap(region)\n\nreturn {\n    data: [{\n        type: 'table',\n        header: {\n            values: header,\n            align: ['left', 'right', 'right', 'right', 'right'],\n            line: { width: 0, color: '#DBDDDE' },\n            font: { family: \"Inter, sans-serif\", size: 14, weight: \"bold\" },\n            fill: {\n                color: ['rgba(0,0,0,0)']\n            }\n        },\n        cells: {\n            values: values,\n            align: ['left', 'right',  'right', 'right', 'right'],\n            line: { width: 1, color: \"#DBDDDE\" },\n            font: { family: \"Inter, sans-serif\", size: 14, color: [\"black\"] },\n            fill: {\n                color: [forecast_colors, ...skill_colors]\n            },\n            height: 35\n        },\n        columnwidth: [0.4, 0.5, 0.5, 0.5, 0.5, 0.5] // Make divider column very thin\n    }],\n    layout: {\n        title: {\n            text: region + \" temperature results\" + units,\n            xanchor: 'left',\n            x: 0\n        }\n    }\n}\n",
        "syncTimeRange": false,
        "timeCol": ""
      },
      "pluginVersion": "1.8.1",
      "targets": [
        {
          "datasource": {
            "type": "grafana-postgresql-datasource",
            "uid": "bdz3m3xs99p1cf"
          },
          "editorMode": "code",
          "format": "table",
          "rawQuery": true,
          "rawSql": "select * from \"$tmp2m_tab_name\"\n ${time_filter_query}",
          "refId": "A",
          "sql": {
            "columns": [
              {
                "parameters": [],
                "type": "function"
              }
            ],
            "groupBy": [
              {
                "property": {
                  "type": "string"
                },
                "type": "groupBy"
              }
            ],
            "limit": 50
          }
        },
        {
          "datasource": {
            "type": "grafana-postgresql-datasource",
            "uid": "bdz3m3xs99p1cf"
          },
          "editorMode": "code",
          "format": "table",
          "hide": false,
          "rawQuery": true,
          "rawSql": "select '${baseline}'",
          "refId": "B",
          "sql": {
            "columns": [
              {
                "parameters": [],
                "type": "function"
              }
            ],
            "groupBy": [
              {
                "property": {
                  "type": "string"
                },
                "type": "groupBy"
              }
            ],
            "limit": 50
          }
        }
      ],
      "title": "",
      "transparent": true,
      "type": "nline-plotlyjs-panel"
    },
    {
      "datasource": {
        "default": true,
        "type": "grafana-postgresql-datasource",
        "uid": "bdz3m3xs99p1cf"
      },
      "fieldConfig": {
        "defaults": {},
        "overrides": [
          {
            "matcher": {
              "id": "byName",
              "options": "forecast"
            },
            "properties": []
          },
          {
            "matcher": {
              "id": "byName",
              "options": "forecast"
            },
            "properties": []
          }
        ]
      },
      "gridPos": {
        "h": 8,
        "w": 12,
        "x": 12,
        "y": 8
      },
      "id": 4,
      "options": {
        "allData": {},
        "config": {},
        "data": [],
        "imgFormat": "png",
        "layout": {
          "font": {
            "family": "Inter, sans-serif"
          },
          "margin": {
            "b": 0,
            "l": 0,
            "r": 0,
            "t": 0
          },
          "paper_bgcolor": "#F4F5F5",
          "plog_bgcolor": "#F4F5F5",
          "title": {
            "align": "left",
            "automargin": true,
            "font": {
              "color": "black",
              "family": "Inter, sans-serif",
              "size": 14,
              "weight": 500
            },
            "pad": {
              "b": 30
            },
            "x": 0,
            "xanchor": "left"
          },
          "xaxis": {
            "automargin": true,
            "autorange": true,
            "type": "date"
          },
          "yaxis": {
            "automargin": true,
            "autorange": true
          }
        },
        "onclick": "",
        "resScale": 0,
        "script": "// Utility function to convert hex color to an RGB object\nfunction hexToRgb(hex) {\n    const bigint = parseInt(hex.slice(1), 16);\n    return {\n        r: (bigint >> 16) & 255,\n        g: (bigint >> 8) & 255,\n        b: bigint & 255\n    };\n}\n\n// Function to get interpolated color by passing a value from 0 to 1\nfunction getColor(value, cmin, cmax, colorMap) {\n    let colors;\n\n    // Define color scales based on the selected colormap\n    if (colorMap === 'BrBG') {\n        colors = [\n            \"#543005\",\n            \"#8C510A\", \"#BF812D\", \"#DFC27D\", \"#F6E8C3\",\n            \"#F5F5F5\", \"#C7EAE5\", \"#80CDC1\", \"#35978F\", \"#01665E\",\n            \"#003C30\"\n        ];\n    } else if (colorMap === 'balance') {\n        colors = [\n            \"#2a0a0a\",\n            \"#751b1b\", \"#b73c3c\", \"#e88484\", \"#f3c3c3\", // Negative side\n            \"#ffffff\",                                            // Neutral middle\n            \"#c3e4f3\", \"#84c2e8\", \"#3c9fb7\", \"#1b5e75\",  // Positive side\n            \"#0a2a2a\"\n        ];\n        colors = colors.reverse()\n    } else if (colorMap === 'RdBu') {\n        colors = ['#ff0000', '#ffffff', '#0000ff'];\n    } else {\n        throw new Error(\"Invalid colorMap. Choose 'BrBG', 'balance', or 'RdBu'.\");\n    }\n\n    let x;\n    if (value > 0) {\n        x = 0.5 + (value / cmax) * 0.5;  // Map positive values from 0.5 to 1.0\n    } else if (value < 0) {\n        x = 0.5 + (value / (-cmin)) * 0.5;  // Map negative values from 0.0 to 0.5\n    } else {\n        x = 0.5;  // Zero maps to middle\n    }    \n\n\n    // Clamp value between 0 and 1\n    x = Math.min(1, Math.max(0, x));\n    if (isNaN(x)) {\n        return `rgba(255, 255, 255, 0.5)`;\n    }\n\n    // Compute exact position in color array\n    const scaledValue = x * (colors.length - 1);\n    const lowerIndex = Math.floor(scaledValue);\n    const upperIndex = Math.ceil(scaledValue);\n\n    // Edge case: if at the end of the array, return the last color\n    if (lowerIndex === upperIndex) {\n        const color = hexToRgb(colors[lowerIndex]);\n        return `rgba(${color.r}, ${color.g}, ${color.b}, 0.5)`;\n    }\n\n    // Interpolate between the two colors\n    const lowerColor = hexToRgb(colors[lowerIndex]);\n    const upperColor = hexToRgb(colors[upperIndex]);\n    const t = scaledValue - lowerIndex;\n\n    // Interpolate RGB channels\n    const r = Math.round(lowerColor.r + t * (upperColor.r - lowerColor.r));\n    const g = Math.round(lowerColor.g + t * (upperColor.g - lowerColor.g));\n    const b = Math.round(lowerColor.b + t * (upperColor.b - lowerColor.b));\n\n    // Return the interpolated color as an rgb(r, g, b) string\n    return `rgba(${r}, ${g}, ${b}, 0.5)`;\n}\n\nlet series = data.series[0]\nif (series.length == 0) {\n    return {\n        data: []\n    }\n}\n\nif (variables.time_grouping.current.value != 'None') {\n    idx = 1\n} else {\n    idx = 0\n}\nforecasts = series.fields[1 + idx].values\nvalues = []\nskills = []\nheader = [\"Forecast\", \"Daily\", \"Weekly\", \"Biweekly\", \"Monthly\"]\norig_header = [\"forecast\", \"daily\", 'weekly', 'biweekly', 'monthly']\nlet max = -Infinity;\nlet min = Infinity;\nlet maximize;\nlet metric = variables['metric'].current.value;\nif (metric.startsWith('heidke') || metric.startsWith('pod') || metric.startsWith('ets')) {\n    maximize = true; // these metrics are maximized\n} else {\n    maximize = false;\n}\n\n\nskill_baseline_idx = null;\nfor (var i = 0; i < forecasts.length; i = i + 1) {\n    if (variables.baseline.current.value == forecasts[i]) {\n        skill_baseline_idx = i\n    }\n}\n\nbaseline_values = []\nfor (var i = 2 + idx; i < series.fields.length; i = i + 1) {\n    baseline_values.push(series.fields[i].values[skill_baseline_idx])\n}\n\nfor (var i = 2 + idx; i < series.fields.length; i = i + 1) {\n    v = series.fields[i].values\n    skill_values = []\n    for (var j = 0; j < v.length; j++) {\n        let val = parseFloat(v[j]);\n        if (val > max) {\n            max = val;\n        }\n        if (val < min) {\n            min = val;\n        }     \n\n        if (isNaN(val) || baseline_values[(i - 2 - idx)] == null || isNaN(baseline_values[(i - 2 - idx)])) {\n            skill_values.push(NaN)\n        }             \n        else if (maximize){\n            // Compute the skill of the distance from 1\n            skill_val = (1 - ((1-val) / (1-baseline_values[(i - 2 - idx)])));\n            skill_values.push(skill_val) \n        } else {\n            skill_val = (1 - (val / baseline_values[(i - 2 - idx)]));\n            skill_values.push(skill_val) \n        }\n    \n               \n    }\n    values.push(v)\n    skills.push(skill_values)\n}\n\nconsole.log(skills)\n\n// round to two decimal places\nvalues = values.map((week) => week.map((x) => { if (x) { return x.toFixed(2) } else { return '-' } }))\nforecasts = forecasts.map((forecast) => forecast.replaceAll('_', ' ').split(' ').map((word) => word[0].toUpperCase() + word.substring(1)).join(' '))\nvalues.unshift(forecasts)\n\n// Rename dictionary\nconst renameDict = {\n    \"Chirps\": \"CHIRPS\",\n    \"Era5\": \"ERA5\",\n    \"Imerg\": \"IMERG\",\n    \"Cbam\": \"CBAM\",\n};\n\n// Apply custom renaming to the first column of cellValues\nvalues[0] = values[0].map(value => renameDict[value] || value);\n\n// assign the forecast colors\nforecast_colors = []\nfor (var i = 0; i < forecasts.length; i++) {\n    forecast_colors.push('rgba(0,0,0,0)')\n}\n\nlet skill_colors = []\n// assign the skill colors\nlet colorMap, cmax, cmin;\n// if (variables['metric'].current.value == 'bias') {\n//     colormap = 'balance';\n//     cmax = max;\n//     cmin = min;\n// }\n// else {\n//     colormap = 'rdbu';\n//     cmax = 1;\n//     cmin = -1;\n// }\n// Determine color map and ranges based on metric\nswitch (variables['metric'].current.value) {\n    case 'bias':\n        colorMap = 'BrBG';\n        [cmin, cmax] = [min, max];\n        break;\n    case 'acc':\n        colorMap = 'RdBu';\n        [cmin, cmax] = [-1, 1];\n        break;\n    case 'pearson':\n        colorMap = 'RdBu';\n        [cmin, cmax] = [-1, 1];\n        break;        \n    // Error metrics - smaller is better\n    case 'mae':\n    case 'crps':\n    case 'rmse':\n    case 'smape':\n    case 'seeps':\n        colorMap = 'RdBu';\n        [cmin, cmax] = [-1, 1];\n        break;\n    // Skill score metrics - larger is better\n    case 'heidke-1-5-10-20':\n    case 'pod-1':\n    case 'pod-5':\n    case 'pod-10':\n    case 'ets-1':\n    case 'ets-5':\n    case 'ets-10':\n        colorMap = 'RdBu';\n        [cmin, cmax] = [-1, 1];\n        break;\n    // FAR metrics - smaller is better\n    case 'far-1':\n    case 'far-5':\n    case 'far-10':\n        colorMap = 'RdBu';\n        [cmin, cmax] = [-1, 1]\n        break;\n    default:\n        colorMap = 'RdBu';\n        [cmin, cmax] = [-1, 1];\n}\n\n\nfor (var i = 0; i < skills.length; i++) {\n    let week_colors = [];\n    for (var j = 0; j < skills[i].length; j++) {\n        if (variables['metric'].current.value == 'acc' || variables['metric'].current.value == 'pearson' || variables['metric'].current.value == 'bias') {\n            val = parseFloat(values[i + 1][j]);\n        } else {\n            val = parseFloat(skills[i][j]);\n        }\n        week_colors.push(getColor(val, cmin, cmax, colorMap))\n    }\n    skill_colors.push(week_colors)\n}\n\nvar units = \"\"\nif (metric == 'mae' || metric == 'bias' || metric == 'crps' || metric == 'rmse') {\n    units = \" (mm/day)\"\n}\n\nvar region = variables['region'].current.value\n\nfunction cap(str) {\n  var i, frags = str.split('_');\n  for (i=0; i<frags.length; i++) {\n    frags[i] = frags[i].charAt(0).toUpperCase() + frags[i].slice(1);\n  }\n  return frags.join(' ');\n}\n\nregion = cap(region)\n\nreturn {\n    data: [{\n        type: 'table',\n        header: {\n            values: header,\n            align: ['left', 'right', 'right', 'right', 'right'],\n            line: { width: 0, color: '#DBDDDE' },\n            font: { family: \"Inter, sans-serif\", size: 14, weight: \"bold\" },\n            fill: {\n                color: ['rgba(0,0,0,0)']\n            }\n        },\n        cells: {\n            values: values,\n            align: ['left', 'right',  'right', 'right', 'right'],\n            line: { width: 1, color: \"#DBDDDE\" },\n            font: { family: \"Inter, sans-serif\", size: 14, color: [\"black\"] },\n            fill: {\n                color: [forecast_colors, ...skill_colors]\n            },\n            height: 35\n        },\n        columnwidth: [0.4, 0.5, 0.5, 0.5, 0.5, 0.5] // Make divider column very thin\n    }],\n    layout: {\n        title: {\n            text: region + \" precipitation results\" + units,\n            xanchor: 'left',\n            x: 0\n        }\n    }\n}\n",
        "syncTimeRange": false,
        "timeCol": ""
      },
      "pluginVersion": "1.8.1",
      "targets": [
        {
          "datasource": {
            "type": "grafana-postgresql-datasource",
            "uid": "bdz3m3xs99p1cf"
          },
          "editorMode": "code",
          "format": "table",
          "rawQuery": true,
          "rawSql": "select * from \"$precip_tab_name\"\n ${time_filter_query}",
          "refId": "A",
          "sql": {
            "columns": [
              {
                "parameters": [],
                "type": "function"
              }
            ],
            "groupBy": [
              {
                "property": {
                  "type": "string"
                },
                "type": "groupBy"
              }
            ],
            "limit": 50
          }
        },
        {
          "datasource": {
            "type": "grafana-postgresql-datasource",
            "uid": "bdz3m3xs99p1cf"
          },
          "editorMode": "code",
          "format": "table",
          "hide": false,
          "rawQuery": true,
          "rawSql": "select '${baseline}'",
          "refId": "B",
          "sql": {
            "columns": [
              {
                "parameters": [],
                "type": "function"
              }
            ],
            "groupBy": [
              {
                "property": {
                  "type": "string"
                },
                "type": "groupBy"
              }
            ],
            "limit": 50
          }
        }
      ],
      "title": "",
      "transparent": true,
      "type": "nline-plotlyjs-panel"
    },
    {
      "datasource": {
        "default": true,
        "type": "grafana-postgresql-datasource",
        "uid": "bdz3m3xs99p1cf"
      },
      "fieldConfig": {
        "defaults": {},
        "overrides": [
          {
            "matcher": {
              "id": "byName",
              "options": "forecast"
            },
            "properties": []
          },
          {
            "matcher": {
              "id": "byName",
              "options": "forecast"
            },
            "properties": []
          }
        ]
      },
      "gridPos": {
        "h": 8,
        "w": 12,
        "x": 0,
        "y": 16
      },
      "id": 6,
      "options": {
        "allData": {},
        "config": {},
        "data": [],
        "imgFormat": "png",
        "layout": {
          "font": {
            "family": "Inter, sans-serif"
          },
          "margin": {
            "b": 0,
            "l": 0,
            "r": 0,
            "t": 0
          },
          "paper_bgcolor": "#F4F5F5",
          "plog_bgcolor": "#F4F5F5",
          "title": {
            "align": "left",
            "automargin": true,
            "font": {
              "color": "black",
              "family": "Inter, sans-serif",
              "size": 14,
              "weight": 500
            },
            "pad": {
              "b": 30
            },
            "x": 0,
            "xanchor": "left"
          },
          "xaxis": {
            "automargin": true,
            "autorange": true,
            "type": "date"
          },
          "yaxis": {
            "automargin": true,
            "autorange": true
          }
        },
        "onclick": "",
        "resScale": 0,
        "script": "// Utility function to convert hex color to an RGB object\nfunction hexToRgb(hex) {\n    const bigint = parseInt(hex.slice(1), 16);\n    return {\n        r: (bigint >> 16) & 255,\n        g: (bigint >> 8) & 255,\n        b: bigint & 255\n    };\n}\n\n// Function to get interpolated color by passing a value from 0 to 1\nfunction getColor(value, cmin, cmax, colorMap) {\n    let colors;\n\n    // Define color scales based on the selected colormap\n    if (colorMap === 'BrBG') {\n        colors = [\n            \"#543005\",\n            \"#8C510A\", \"#BF812D\", \"#DFC27D\", \"#F6E8C3\",\n            \"#F5F5F5\", \"#C7EAE5\", \"#80CDC1\", \"#35978F\", \"#01665E\",\n            \"#003C30\"\n        ];\n    } else if (colorMap === 'balance') {\n        colors = [\n            \"#2a0a0a\",\n            \"#751b1b\", \"#b73c3c\", \"#e88484\", \"#f3c3c3\", // Negative side\n            \"#ffffff\",                                            // Neutral middle\n            \"#c3e4f3\", \"#84c2e8\", \"#3c9fb7\", \"#1b5e75\",  // Positive side\n            \"#0a2a2a\"\n        ];\n        colors = colors.reverse()\n    } else if (colorMap === 'RdBu') {\n        colors = ['#ff0000', '#ffffff', '#0000ff'];\n    } else if (colorMap === 'BuRd') {\n        colors = ['#0000ff', '#ffffff', '#ff0000'];                \n    } else {\n        throw new Error(\"Invalid colorMap. Choose 'BrBG', 'balance', or 'RdBu'.\");\n    }\n\n    let x;\n    if (value > 0) {\n        x = 0.5 + (value / cmax) * 0.5;  // Map positive values from 0.5 to 1.0\n    } else if (value < 0) {\n        x = 0.5 + (value / (-cmin)) * 0.5;  // Map negative values from 0.0 to 0.5\n    } else {\n        x = 0.5;  // Zero maps to middle\n    }    \n\n\n    // Clamp value between 0 and 1\n    x = Math.min(1, Math.max(0, x));\n    if (isNaN(x)) {\n        return `rgba(255, 255, 255, 0.5)`;\n    }\n\n    // Compute exact position in color array\n    const scaledValue = x * (colors.length - 1);\n    const lowerIndex = Math.floor(scaledValue);\n    const upperIndex = Math.ceil(scaledValue);\n\n    // Edge case: if at the end of the array, return the last color\n    if (lowerIndex === upperIndex) {\n        const color = hexToRgb(colors[lowerIndex]);\n        return `rgba(${color.r}, ${color.g}, ${color.b}, 0.5)`;\n    }\n\n    // Interpolate between the two colors\n    const lowerColor = hexToRgb(colors[lowerIndex]);\n    const upperColor = hexToRgb(colors[upperIndex]);\n    const t = scaledValue - lowerIndex;\n\n    // Interpolate RGB channels\n    const r = Math.round(lowerColor.r + t * (upperColor.r - lowerColor.r));\n    const g = Math.round(lowerColor.g + t * (upperColor.g - lowerColor.g));\n    const b = Math.round(lowerColor.b + t * (upperColor.b - lowerColor.b));\n\n    // Return the interpolated color as an rgb(r, g, b) string\n    return `rgba(${r}, ${g}, ${b}, 0.5)`;\n}\n\nlet series = data.series[0]\nif (series.length == 0) {\n    return {\n        data: []\n    }\n}\n\nif (variables.time_grouping.current.value != 'None') {\n    idx = 1\n} else {\n    idx = 0\n}\nforecasts = series.fields[1 + idx].values\nvalues = []\nskills = []\nheader = [\"Forecast\", \"Daily\", \"Weekly\", \"Biweekly\", \"Monthly\"]\norig_header = [\"forecast\", \"daily\", 'weekly', 'biweekly', 'monthly']\nlet max = -Infinity;\nlet min = Infinity;\n\nskill_baseline_idx = null;\nfor (var i = 0; i < forecasts.length; i = i + 1) {\n    if (variables.baseline.current.value == forecasts[i]) {\n        skill_baseline_idx = i\n    }\n}\n\nbaseline_values = []\nfor (var i = 2 + idx; i < series.fields.length; i = i + 1) {\n    baseline_values.push(series.fields[i].values[skill_baseline_idx])\n}\n\nfor (var i = 2 + idx; i < series.fields.length; i = i + 1) {\n    v = series.fields[i].values\n    skill_values = []\n    for (var j = 0; j < v.length; j++) {\n        let val = parseFloat(v[j]);\n        if (val > max) {\n            max = val;\n        }\n        if (val < min) {\n            min = val;\n        }     \n        if (isNaN(val) || baseline_values[(i - 2 - idx)] == null || isNaN(baseline_values[(i - 2 - idx)])) {\n            skill_values.push(NaN)\n        }      \n        else{\n            skill_values.push((1 - (val / baseline_values[(i - 2 - idx)])))\n        }\n    }\n    values.push(v)\n    skills.push(skill_values)\n}\n\nconsole.log(skills)\n\n// round to two decimal places\nvalues = values.map((week) => week.map((x) => { if (x) { return x.toFixed(2) } else { return '-' } }))\nforecasts = forecasts.map((forecast) => forecast.replaceAll('_', ' ').split(' ').map((word) => word[0].toUpperCase() + word.substring(1)).join(' '))\nvalues.unshift(forecasts)\n\n// Rename dictionary\nconst renameDict = {\n    \"Chirps\": \"CHIRPS\",\n    \"Era5\": \"ERA5\",\n    \"Imerg\": \"IMERG\",\n    \"Cbam\": \"CBAM\",\n};\n\n// Apply custom renaming to the first column of cellValues\nvalues[0] = values[0].map(value => renameDict[value] || value);\n\n// assign the forecast colors\nforecast_colors = []\nfor (var i = 0; i < forecasts.length; i++) {\n    forecast_colors.push('rgba(0,0,0,0)')\n}\n\nlet skill_colors = []\n// assign the skill colors\nlet colorMap, cmax, cmin;\n// if (variables['metric'].current.value == 'bias') {\n//     colormap = 'balance';\n//     cmax = max;\n//     cmin = min;\n// }\n// else {\n//     colormap = 'rdbu';\n//     cmax = 1;\n//     cmin = -1;\n// }\n// Determine color map and ranges based on metric\nswitch (variables['metric'].current.value) {\n    case 'bias':\n        colorMap = 'BuRd';\n        [cmin, cmax] = [min, max];\n        break;\n    case 'acc':\n        colorMap = 'RdBu';\n        [cmin, cmax] = [-1, 1];\n        break;\n    // Error metrics - smaller is better\n    case 'mae':\n    case 'crps':\n    case 'rmse':\n    case 'smape':\n    case 'seeps':\n        colorMap = 'RdBu';\n        [cmin, cmax] = [-1, 1];\n        break;\n    // Skill score metrics - larger is better\n    case 'heidke-1-5-10-20':\n    case 'pod-1':\n    case 'pod-5':\n    case 'pod-10':\n    case 'ets-1':\n    case 'ets-5':\n    case 'ets-10':\n        colorMap = 'RdBu';\n        [cmin, cmax] = [0, 1];\n        break;\n    // FAR metrics - smaller is better\n    case 'far-1':\n    case 'far-5':\n    case 'far-10':\n        colorMap = 'RdBu';\n        [cmin, cmax] = [0, 1];\n        break;\n    default:\n        colorMap = 'RdBu';\n        [cmax, cmin] = [1, -1];\n}\n\nfor (var i = 0; i < skills.length; i++) {\n    let week_colors = [];\n    for (var j = 0; j < skills[i].length; j++) {\n        if (variables['metric'].current.value == 'acc' || variables['metric'].current.value == 'bias') {\n            val = parseFloat(values[i + 1][j]);\n        } else {\n            val = parseFloat(skills[i][j]);\n        }\n        week_colors.push(getColor(val, cmin, cmax, colorMap))\n    }\n    skill_colors.push(week_colors)\n}\n\nlet metric = variables['metric'].current.value\n\nvar units = \"\"\nif (metric == 'mae' || metric == 'bias' || metric == 'crps' || metric == 'rmse') {\n    units = \" (C)\"\n}\n\nvar region = variables['region2'].current.value\n\nfunction cap(str) {\n  var i, frags = str.split('_');\n  for (i=0; i<frags.length; i++) {\n    frags[i] = frags[i].charAt(0).toUpperCase() + frags[i].slice(1);\n  }\n  return frags.join(' ');\n}\n\nregion = cap(region)\n\nreturn {\n    data: [{\n        type: 'table',\n        header: {\n            values: header,\n            align: ['left', 'right', 'right', 'right', 'right'],\n            line: { width: 0, color: '#DBDDDE' },\n            font: { family: \"Inter, sans-serif\", size: 14, weight: \"bold\" },\n            fill: {\n                color: ['rgba(0,0,0,0)']\n            }\n        },\n        cells: {\n            values: values,\n            align: ['left', 'right',  'right', 'right', 'right'],\n            line: { width: 1, color: \"#DBDDDE\" },\n            font: { family: \"Inter, sans-serif\", size: 14, color: [\"black\"] },\n            fill: {\n                color: [forecast_colors, ...skill_colors]\n            },\n            height: 35\n        },\n        columnwidth: [0.4, 0.5, 0.5, 0.5, 0.5, 0.5] // Make divider column very thin\n    }],\n    layout: {\n        title: {\n            text: region + \" temperature results\" + units,\n            xanchor: 'left',\n            x: 0\n        }\n    }\n}\n",
        "syncTimeRange": false,
        "timeCol": ""
      },
      "pluginVersion": "1.8.1",
      "targets": [
        {
          "datasource": {
            "type": "grafana-postgresql-datasource",
            "uid": "bdz3m3xs99p1cf"
          },
          "editorMode": "code",
          "format": "table",
          "rawQuery": true,
          "rawSql": "select * from \"$tmp2m2_tab_name\"\n ${time_filter_query}",
          "refId": "A",
          "sql": {
            "columns": [
              {
                "parameters": [],
                "type": "function"
              }
            ],
            "groupBy": [
              {
                "property": {
                  "type": "string"
                },
                "type": "groupBy"
              }
            ],
            "limit": 50
          }
        },
        {
          "datasource": {
            "type": "grafana-postgresql-datasource",
            "uid": "bdz3m3xs99p1cf"
          },
          "editorMode": "code",
          "format": "table",
          "hide": false,
          "rawQuery": true,
          "rawSql": "select '${baseline}'",
          "refId": "B",
          "sql": {
            "columns": [
              {
                "parameters": [],
                "type": "function"
              }
            ],
            "groupBy": [
              {
                "property": {
                  "type": "string"
                },
                "type": "groupBy"
              }
            ],
            "limit": 50
          }
        }
      ],
      "title": "",
      "transparent": true,
      "type": "nline-plotlyjs-panel"
    },
    {
      "datasource": {
        "default": true,
        "type": "grafana-postgresql-datasource",
        "uid": "bdz3m3xs99p1cf"
      },
      "fieldConfig": {
        "defaults": {},
        "overrides": [
          {
            "matcher": {
              "id": "byName",
              "options": "forecast"
            },
            "properties": []
          },
          {
            "matcher": {
              "id": "byName",
              "options": "forecast"
            },
            "properties": []
          }
        ]
      },
      "gridPos": {
        "h": 8,
        "w": 12,
        "x": 12,
        "y": 16
      },
      "id": 5,
      "options": {
        "allData": {},
        "config": {},
        "data": [],
        "imgFormat": "png",
        "layout": {
          "font": {
            "family": "Inter, sans-serif"
          },
          "margin": {
            "b": 0,
            "l": 0,
            "r": 0,
            "t": 0
          },
          "paper_bgcolor": "#F4F5F5",
          "plog_bgcolor": "#F4F5F5",
          "title": {
            "align": "left",
            "automargin": true,
            "font": {
              "color": "black",
              "family": "Inter, sans-serif",
              "size": 14,
              "weight": 500
            },
            "pad": {
              "b": 30
            },
            "x": 0,
            "xanchor": "left"
          },
          "xaxis": {
            "automargin": true,
            "autorange": true,
            "type": "date"
          },
          "yaxis": {
            "automargin": true,
            "autorange": true
          }
        },
        "onclick": "",
        "resScale": 0,
        "script": "// Utility function to convert hex color to an RGB object\nfunction hexToRgb(hex) {\n    const bigint = parseInt(hex.slice(1), 16);\n    return {\n        r: (bigint >> 16) & 255,\n        g: (bigint >> 8) & 255,\n        b: bigint & 255\n    };\n}\n\n// Function to get interpolated color by passing a value from 0 to 1\nfunction getColor(value, cmin, cmax, colorMap) {\n    let colors;\n\n    // Define color scales based on the selected colormap\n    if (colorMap === 'BrBG') {\n        colors = [\n            \"#543005\",\n            \"#8C510A\", \"#BF812D\", \"#DFC27D\", \"#F6E8C3\",\n            \"#F5F5F5\", \"#C7EAE5\", \"#80CDC1\", \"#35978F\", \"#01665E\",\n            \"#003C30\"\n        ];\n    } else if (colorMap === 'balance') {\n        colors = [\n            \"#2a0a0a\",\n            \"#751b1b\", \"#b73c3c\", \"#e88484\", \"#f3c3c3\", // Negative side\n            \"#ffffff\",                                            // Neutral middle\n            \"#c3e4f3\", \"#84c2e8\", \"#3c9fb7\", \"#1b5e75\",  // Positive side\n            \"#0a2a2a\"\n        ];\n        colors = colors.reverse()\n    } else if (colorMap === 'RdBu') {\n        colors = ['#ff0000', '#ffffff', '#0000ff'];\n    } else {\n        throw new Error(\"Invalid colorMap. Choose 'BrBG', 'balance', or 'RdBu'.\");\n    }\n\n    let x;\n    if (value > 0) {\n        x = 0.5 + (value / cmax) * 0.5;  // Map positive values from 0.5 to 1.0\n    } else if (value < 0) {\n        x = 0.5 + (value / (-cmin)) * 0.5;  // Map negative values from 0.0 to 0.5\n    } else {\n        x = 0.5;  // Zero maps to middle\n    }    \n\n    // Clamp value between 0 and 1\n    x = Math.min(1, Math.max(0, x));\n    if (isNaN(x)) {\n        return `rgba(255, 255, 255, 0.5)`;\n    }\n\n    // Compute exact position in color array\n    const scaledValue = x * (colors.length - 1);\n    const lowerIndex = Math.floor(scaledValue);\n    const upperIndex = Math.ceil(scaledValue);\n\n    // Edge case: if at the end of the array, return the last color\n    if (lowerIndex === upperIndex) {\n        const color = hexToRgb(colors[lowerIndex]);\n        return `rgba(${color.r}, ${color.g}, ${color.b}, 0.5)`;\n    }\n\n    // Interpolate between the two colors\n    const lowerColor = hexToRgb(colors[lowerIndex]);\n    const upperColor = hexToRgb(colors[upperIndex]);\n    const t = scaledValue - lowerIndex;\n\n    // Interpolate RGB channels\n    const r = Math.round(lowerColor.r + t * (upperColor.r - lowerColor.r));\n    const g = Math.round(lowerColor.g + t * (upperColor.g - lowerColor.g));\n    const b = Math.round(lowerColor.b + t * (upperColor.b - lowerColor.b));\n\n    // Return the interpolated color as an rgb(r, g, b) string\n    return `rgba(${r}, ${g}, ${b}, 0.5)`;\n}\n\nlet series = data.series[0]\nif (series.length == 0) {\n    return {\n        data: []\n    }\n}\n\nif (variables.time_grouping.current.value != 'None') {\n    idx = 1\n} else {\n    idx = 0\n}\nforecasts = series.fields[1 + idx].values\nvalues = []\nskills = []\nheader = [\"Forecast\", \"Daily\", \"Weekly\", \"Biweekly\", \"Monthly\"]\norig_header = [\"forecast\", \"daily\", 'weekly', 'biweekly', 'monthly']\nlet max = -Infinity;\nlet min = Infinity;\nlet maximize;\nlet metric = variables['metric'].current.value;\nif (metric.startsWith('heidke') || metric.startsWith('pod') || metric.startsWith('ets')) {\n    maximize = true; // these metrics are maximized\n} else {\n    maximize = false;\n}\n\n\nskill_baseline_idx = null;\nfor (var i = 0; i < forecasts.length; i = i + 1) {\n    if (variables.baseline.current.value == forecasts[i]) {\n        skill_baseline_idx = i\n    }\n}\n\nconsole.log(skill_baseline_idx)\n\nbaseline_values = []\nfor (var i = 2 + idx; i < series.fields.length; i = i + 1) {\n    baseline_values.push(series.fields[i].values[skill_baseline_idx])\n}\n\nfor (var i = 2 + idx; i < series.fields.length; i = i + 1) {\n    v = series.fields[i].values\n    skill_values = []\n    for (var j = 0; j < v.length; j++) {\n        let val = parseFloat(v[j]);\n        if (val > max) {\n            max = val;\n        }\n        if (val < min) {\n            min = val;\n        }     \n\n        if (isNaN(val) || baseline_values[(i - 2 - idx)] == null || isNaN(baseline_values[(i - 2 - idx)])) {\n            skill_values.push(NaN)\n        }             \n        else if (maximize){\n            // Compute the skill of the distance from 1\n            skill_val = (1 - ((1-val) / (1-baseline_values[(i - 2 - idx)])));\n            skill_values.push(skill_val)  \n        } else {\n            skill_val = (1 - (val / baseline_values[(i - 2 - idx)]));\n            skill_values.push(skill_val)  \n        }\n              \n    }\n    values.push(v)\n    skills.push(skill_values)\n}\n\nconsole.log(skills)\n\n// round to two decimal places\nvalues = values.map((week) => week.map((x) => { if (x) { return x.toFixed(2) } else { return '-' } }))\nforecasts = forecasts.map((forecast) => forecast.replaceAll('_', ' ').split(' ').map((word) => word[0].toUpperCase() + word.substring(1)).join(' '))\nvalues.unshift(forecasts)\n\n// Rename dictionary\nconst renameDict = {\n    \"Chirps\": \"CHIRPS\",\n    \"Era5\": \"ERA5\",\n    \"Imerg\": \"IMERG\",\n    \"Cbam\": \"CBAM\",\n};\n\n// Apply custom renaming to the first column of cellValues\nvalues[0] = values[0].map(value => renameDict[value] || value);\n\n// assign the forecast colors\nforecast_colors = []\nfor (var i = 0; i < forecasts.length; i++) {\n    forecast_colors.push('rgba(0,0,0,0)')\n}\n\nlet skill_colors = []\n// assign the skill colors\nlet colorMap, cmax, cmin;\n// if (variables['metric'].current.value == 'bias') {\n//     colormap = 'balance';\n//     cmax = max;\n//     cmin = min;\n// }\n// else {\n//     colormap = 'rdbu';\n//     cmax = 1;\n//     cmin = -1;\n// }\n// Determine color map and ranges based on metric\nswitch (variables['metric'].current.value) {\n    case 'bias':\n        colorMap = 'BrBG';\n        [cmin, cmax] = [min, max];\n        break;\n    case 'acc':\n        colorMap = 'RdBu';\n        [cmin, cmax] = [-1, 1];\n        break;\n    case 'pearson':\n        colorMap = 'RdBu';\n        [cmin, cmax] = [-1, 1];\n        break;        \n    // Error metrics - smaller is better\n    case 'mae':\n    case 'crps':\n    case 'rmse':\n    case 'smape':\n    case 'seeps':\n        colorMap = 'RdBu';\n        [cmin, cmax] = [-1, 1];\n        break;\n    // Skill score metrics - larger is better\n    case 'heidke-1-5-10-20':\n    case 'pod-1':\n    case 'pod-5':\n    case 'pod-10':\n    case 'ets-1':\n    case 'ets-5':\n    case 'ets-10':\n        colorMap = 'RdBu';\n        [cmin, cmax] = [-1, 1];\n        break;\n    // FAR metrics - smaller is better\n    case 'far-1':\n    case 'far-5':\n    case 'far-10':\n        colorMap = 'RdBu';\n        [cmin, cmax] = [-1, 1]\n        break;\n    default:\n        colorMap = 'RdBu';\n        [cmin, cmax] = [-1, 1];\n}\n\n\nfor (var i = 0; i < skills.length; i++) {\n    let week_colors = [];\n    for (var j = 0; j < skills[i].length; j++) {\n        if (variables['metric'].current.value == 'acc' || variables['metric'].current.value == 'pearson' ||  variables['metric'].current.value == 'bias') {\n            val = parseFloat(values[i + 1][j]);\n        } else {\n            val = parseFloat(skills[i][j]);\n        }\n        week_colors.push(getColor(val, cmin, cmax, colorMap))\n    }\n    skill_colors.push(week_colors)\n}\n\n\nvar units = \"\"\nif (metric == 'mae' || metric == 'bias' || metric == 'crps' || metric == 'rmse') {\n    units = \" (mm/day)\"\n}\n\nvar region = variables['region2'].current.value\n\nfunction cap(str) {\n  var i, frags = str.split('_');\n  for (i=0; i<frags.length; i++) {\n    frags[i] = frags[i].charAt(0).toUpperCase() + frags[i].slice(1);\n  }\n  return frags.join(' ');\n}\n\nregion = cap(region)\n\nreturn {\n    data: [{\n        type: 'table',\n        header: {\n            values: header,\n            align: ['left', 'right', 'right', 'right', 'right'],\n            line: { width: 0, color: '#DBDDDE' },\n            font: { family: \"Inter, sans-serif\", size: 14, weight: \"bold\" },\n            fill: {\n                color: ['rgba(0,0,0,0)']\n            }\n        },\n        cells: {\n            values: values,\n            align: ['left', 'right',  'right', 'right', 'right'],\n            line: { width: 1, color: \"#DBDDDE\" },\n            font: { family: \"Inter, sans-serif\", size: 14, color: [\"black\"] },\n            fill: {\n                color: [forecast_colors, ...skill_colors]\n            },\n            height: 35\n        },\n        columnwidth: [0.4, 0.5, 0.5, 0.5, 0.5, 0.5] // Make divider column very thin\n    }],\n    layout: {\n        title: {\n            text: region + \" precipitation results\" + units,\n            xanchor: 'left',\n            x: 0\n        }\n    }\n}\n",
        "syncTimeRange": false,
        "timeCol": ""
      },
      "pluginVersion": "1.8.1",
      "targets": [
        {
          "datasource": {
            "type": "grafana-postgresql-datasource",
            "uid": "bdz3m3xs99p1cf"
          },
          "editorMode": "code",
          "format": "table",
          "rawQuery": true,
          "rawSql": "select * from \"$precip2_tab_name\"\n ${time_filter_query}",
          "refId": "A",
          "sql": {
            "columns": [
              {
                "parameters": [],
                "type": "function"
              }
            ],
            "groupBy": [
              {
                "property": {
                  "type": "string"
                },
                "type": "groupBy"
              }
            ],
            "limit": 50
          }
        },
        {
          "datasource": {
            "type": "grafana-postgresql-datasource",
            "uid": "bdz3m3xs99p1cf"
          },
          "editorMode": "code",
          "format": "table",
          "hide": false,
          "rawQuery": true,
          "rawSql": "select '${baseline}'",
          "refId": "B",
          "sql": {
            "columns": [
              {
                "parameters": [],
                "type": "function"
              }
            ],
            "groupBy": [
              {
                "property": {
                  "type": "string"
                },
                "type": "groupBy"
              }
            ],
            "limit": 50
          }
        }
      ],
      "title": "",
      "transparent": true,
      "type": "nline-plotlyjs-panel"
    }
  ],
  "preload": false,
  "refresh": "",
  "schemaVersion": 40,
  "tags": [],
  "templating": {
    "list": [
      {
        "current": {
          "text": "pearson",
          "value": "pearson"
        },
        "includeAll": false,
        "label": "Metric",
        "name": "metric",
        "options": [
          {
            "selected": false,
            "text": "MAE",
            "value": "mae"
          },
          {
            "selected": false,
            "text": "RMSE",
            "value": "rmse"
          },
          {
            "selected": false,
            "text": "Bias",
            "value": "bias"
          },
          {
            "selected": false,
            "text": "ACC",
            "value": "acc"
          },
          {
            "selected": true,
            "text": "Pearson",
            "value": "pearson"
          },
          {
            "selected": false,
            "text": "SMAPE",
            "value": "smape"
          },
          {
            "selected": false,
            "text": "Heidke (1/5/10/20mm)",
            "value": "heidke-1-5-10-20"
          },
          {
            "selected": false,
            "text": "POD 1mm",
            "value": "pod-1"
          },
          {
            "selected": false,
            "text": "POD 5mm",
            "value": "pod-5"
          },
          {
            "selected": false,
            "text": "POD 10mm",
            "value": "pod-10"
          },
          {
            "selected": false,
            "text": "FAR 1mm",
            "value": "far-1"
          },
          {
            "selected": false,
            "text": "FAR 5mm",
            "value": "far-5"
          },
          {
            "selected": false,
            "text": "FAR 10mm",
            "value": "far-10"
          },
          {
            "selected": false,
            "text": "ETS 1mm",
            "value": "ets-1"
          },
          {
            "selected": false,
            "text": "ETS 5mm",
            "value": "ets-5"
          },
          {
            "selected": false,
            "text": "ETS 10mm",
            "value": "ets-10"
          }
        ],
        "query": "MAE : mae, RMSE : rmse, Bias : bias, ACC : acc, Pearson : pearson, SMAPE : smape, Heidke (1/5/10/20mm) : heidke-1-5-10-20, POD 1mm : pod-1, POD 5mm : pod-5, POD 10mm : pod-10, FAR 1mm : far-1, FAR 5mm : far-5, FAR 10mm : far-10, ETS 1mm : ets-1, ETS 5mm : ets-5, ETS 10mm : ets-10",
        "type": "custom"
      },
      {
        "current": {
          "text": "ghcn",
          "value": "ghcn"
        },
        "includeAll": false,
        "label": "Station Type",
        "name": "truth",
        "options": [
          {
            "selected": true,
            "text": "GHCN Random",
            "value": "ghcn"
          },
          {
            "selected": false,
            "text": "GHCN Average",
            "value": "ghcn_avg"
          },
          {
            "selected": false,
            "text": "TAHMO Random",
            "value": "tahmo"
          },
          {
            "selected": false,
            "text": "TAHMO Average",
            "value": "tahmo_avg"
          }
        ],
        "query": "GHCN Random : ghcn, GHCN Average : ghcn_avg, TAHMO Random : tahmo, TAHMO Average : tahmo_avg",
        "type": "custom"
      },
      {
        "current": {
          "text": "africa",
          "value": "africa"
        },
        "includeAll": false,
        "label": "First Region",
        "name": "region",
        "options": [
          {
            "selected": true,
            "text": "Africa",
            "value": "africa"
          },
          {
            "selected": false,
            "text": "East Africa",
            "value": "east_africa"
          },
          {
            "selected": false,
            "text": "Global",
            "value": "global"
          },
          {
            "selected": false,
            "text": "CONUS",
            "value": "conus"
          }
        ],
        "query": "Africa : africa, East Africa : east_africa, Global : global, CONUS : conus",
        "type": "custom"
      },
      {
        "current": {
          "text": "conus",
          "value": "conus"
        },
        "includeAll": false,
        "label": "Second Region",
        "name": "region2",
        "options": [
          {
            "selected": false,
            "text": "Africa",
            "value": "africa"
          },
          {
            "selected": false,
            "text": "East Africa",
            "value": "east_africa"
          },
          {
            "selected": false,
            "text": "Global",
            "value": "global"
          },
          {
            "selected": true,
            "text": "CONUS",
            "value": "conus"
          }
        ],
        "query": "Africa : africa, East Africa : east_africa, Global : global, CONUS : conus",
        "type": "custom"
      },
      {
        "current": {
          "text": "CHIRPS",
          "value": "chirps"
        },
        "definition": "select \nforecast as __value,\ncase\n when forecast = 'chirps' then 'CHIRPS' \nwhen forecast = 'era5' then 'ERA5' \nwhen forecast = 'imerg' then 'IMERG' \nwhen forecast = 'cbam' then 'CBAM' \n else forecast\nend as __text\nfrom \"${precip_tab_name}\" where daily is not null",
        "label": "Baseline",
        "name": "baseline",
        "options": [],
        "query": "select \nforecast as __value,\ncase\n when forecast = 'chirps' then 'CHIRPS' \nwhen forecast = 'era5' then 'ERA5' \nwhen forecast = 'imerg' then 'IMERG' \nwhen forecast = 'cbam' then 'CBAM' \n else forecast\nend as __text\nfrom \"${precip_tab_name}\" where daily is not null",
        "refresh": 1,
        "regex": "",
        "type": "query"
      },
      {
        "current": {
          "text": "global1_5",
          "value": "global1_5"
        },
        "includeAll": false,
        "label": "Grid",
        "name": "grid",
        "options": [
          {
            "selected": true,
            "text": "1.5",
            "value": "global1_5"
          },
          {
            "selected": false,
            "text": "0.25",
            "value": "global0_25"
          }
        ],
        "query": "1.5 : global1_5, 0.25 : global0_25",
        "type": "custom"
      },
      {
        "current": {
          "text": "None",
          "value": "None"
        },
        "includeAll": false,
        "label": "Time Grouping",
        "name": "time_grouping",
        "options": [
          {
            "selected": true,
            "text": "None",
            "value": "None"
          },
          {
            "selected": false,
            "text": "Month of Year",
            "value": "month_of_year"
          },
          {
            "selected": false,
            "text": "Year",
            "value": "year"
          }
        ],
        "query": "None : None, Month of Year : month_of_year, Year : year",
        "type": "custom"
      },
      {
        "current": {
          "text": "99c748ea6cd4ffd36f7305bfe11668b9",
          "value": "99c748ea6cd4ffd36f7305bfe11668b9"
        },
        "datasource": {
          "type": "grafana-postgresql-datasource",
          "uid": "bdz3m3xs99p1cf"
        },
        "definition": "select * from md5('station_metrics_table/2022-12-31_${grid}_lsm_${metric}_${region}_2016-01-01_${time_grouping}_${truth}_tmp2m')",
        "hide": 2,
        "includeAll": false,
        "name": "tmp2m_tab_name",
        "options": [],
        "query": "select * from md5('station_metrics_table/2022-12-31_${grid}_lsm_${metric}_${region}_2016-01-01_${time_grouping}_${truth}_tmp2m')",
        "refresh": 2,
        "regex": "",
        "type": "query"
      },
      {
        "current": {
          "text": "d5a84635903fc0f32e6b09f6ec6d2330",
          "value": "d5a84635903fc0f32e6b09f6ec6d2330"
        },
        "datasource": {
          "type": "grafana-postgresql-datasource",
          "uid": "bdz3m3xs99p1cf"
        },
        "definition": "select * from md5('station_metrics_table/2022-12-31_${grid}_lsm_${metric}_${region2}_2016-01-01_${time_grouping}_${truth}_tmp2m')",
        "hide": 2,
        "includeAll": false,
        "name": "tmp2m2_tab_name",
        "options": [],
        "query": "select * from md5('station_metrics_table/2022-12-31_${grid}_lsm_${metric}_${region2}_2016-01-01_${time_grouping}_${truth}_tmp2m')",
        "refresh": 2,
        "regex": "",
        "type": "query"
      },
      {
        "current": {
          "text": "3fb874dfb510209c938ab048a64f11d2",
          "value": "3fb874dfb510209c938ab048a64f11d2"
        },
        "datasource": {
          "type": "grafana-postgresql-datasource",
          "uid": "bdz3m3xs99p1cf"
        },
        "definition": "select * from md5('station_metrics_table/2022-12-31_${grid}_lsm_${metric}_${region}_2016-01-01_${time_grouping}_${truth}_precip')",
        "hide": 2,
        "includeAll": false,
        "name": "precip_tab_name",
        "options": [],
        "query": "select * from md5('station_metrics_table/2022-12-31_${grid}_lsm_${metric}_${region}_2016-01-01_${time_grouping}_${truth}_precip')",
        "refresh": 2,
        "regex": "",
        "type": "query"
      },
      {
        "current": {
          "text": "6e2341d928a83a3c87ec082dd7a71ac3",
          "value": "6e2341d928a83a3c87ec082dd7a71ac3"
        },
        "datasource": {
          "type": "grafana-postgresql-datasource",
          "uid": "bdz3m3xs99p1cf"
        },
        "definition": "select * from md5('station_metrics_table/2022-12-31_${grid}_lsm_${metric}_${region2}_2016-01-01_${time_grouping}_${truth}_precip')",
        "hide": 2,
        "includeAll": false,
        "name": "precip2_tab_name",
        "options": [],
        "query": "select * from md5('station_metrics_table/2022-12-31_${grid}_lsm_${metric}_${region2}_2016-01-01_${time_grouping}_${truth}_precip')",
        "refresh": 2,
        "regex": "",
        "type": "query"
      },
      {
        "current": {
          "text": "select v.* from (values ('None')) v(t)",
          "value": "select v.* from (values ('None')) v(t)"
        },
        "datasource": {
          "type": "grafana-postgresql-datasource",
          "uid": "bdz3m3xs99p1cf"
        },
        "definition": "select \nCASE\n    WHEN v.g = 'None' THEN 'select v.* from (values (''None'')) v(t)'\n    ELSE 'select distinct time from \"${precip_tab_name}\"'\nEND\nfrom (values ('$time_grouping')) v(g)",
        "hide": 2,
        "includeAll": false,
        "name": "time_filter_filter_query",
        "options": [],
        "query": "select \nCASE\n    WHEN v.g = 'None' THEN 'select v.* from (values (''None'')) v(t)'\n    ELSE 'select distinct time from \"${precip_tab_name}\"'\nEND\nfrom (values ('$time_grouping')) v(g)",
        "refresh": 1,
        "regex": "",
        "type": "query"
      },
      {
        "current": {
          "text": "None",
          "value": "None"
        },
        "datasource": {
          "type": "grafana-postgresql-datasource",
          "uid": "bdz3m3xs99p1cf"
        },
        "definition": "${time_filter_filter_query:raw}",
        "includeAll": false,
        "label": "Time Filter",
        "name": "time_filter",
        "options": [],
        "query": "${time_filter_filter_query:raw}",
        "refresh": 1,
        "regex": "",
        "sort": 5,
        "type": "query"
      },
      {
        "current": {
          "text": "",
          "value": ""
        },
        "datasource": {
          "type": "grafana-postgresql-datasource",
          "uid": "bdz3m3xs99p1cf"
        },
        "definition": "select \nCASE\n    WHEN v.g = 'None' THEN ''\n    ELSE 'where time = ' || v.t\nEND\nfrom (values ('$time_filter', '$time_grouping')) v(t, g)",
        "hide": 2,
        "includeAll": false,
        "name": "time_filter_query",
        "options": [],
        "query": "select \nCASE\n    WHEN v.g = 'None' THEN ''\n    ELSE 'where time = ' || v.t\nEND\nfrom (values ('$time_filter', '$time_grouping')) v(t, g)",
        "refresh": 1,
        "regex": "",
        "type": "query"
      },
      {
        "current": {
          "text": "1.5",
          "value": "1.5"
        },
        "hide": 2,
        "includeAll": false,
        "name": "lat",
        "options": [
          {
            "selected": true,
            "text": "1.5",
            "value": "1.5"
          }
        ],
        "query": "1.5",
        "type": "custom"
      },
      {
        "current": {
          "text": "39.0",
          "value": "39.0"
        },
        "hide": 2,
        "includeAll": false,
        "name": "lon",
        "options": [
          {
            "selected": true,
            "text": "39.0",
            "value": "39.0"
          }
        ],
        "query": "39.0",
        "type": "custom"
      },
      {
        "current": {
          "text": "b9f5260020f8a2b45d03f686d30d691f",
          "value": "b9f5260020f8a2b45d03f686d30d691f"
        },
        "datasource": {
          "type": "grafana-postgresql-datasource",
          "uid": "bdz3m3xs99p1cf"
        },
        "definition": "select * from md5('rain_windowed_spw/${grid}_lsm_kenya_${rain_data}')",
        "hide": 2,
        "includeAll": false,
        "name": "rainfall_tab_name",
        "options": [],
        "query": "select * from md5('rain_windowed_spw/${grid}_lsm_kenya_${rain_data}')",
        "refresh": 1,
        "regex": "",
        "type": "query"
      }
    ]
  },
  "time": {
    "from": "now-6h",
    "to": "now"
  },
  "timepicker": {
    "hidden": true
  },
  "timezone": "utc",
  "title": "Reanalysis Evaluation",
  "uid": "ce6tgp4j3d9fkf",
  "version": 97,
  "weekStart": ""
}
